# Тестирование и Pytest
## Содержание
#### Введение в Pytest (без кода)
- **Обзор Pytest**: Что такое Pytest и почему он популярен среди разработчиков.
- **Сравнение Pytest и Unittest:** Преимущества и недостатки
- **Установка Pytest**: Пошаговая инструкция по установке и настройке.
- **Первый тест с Pytest**: Написание и выполнение простого теста.
- **Основы утверждений**: Как использовать утверждения для проверки результатов.
- **Работа с результатами**: Понимание вывода тестов и отчетов.

#### Размещение и конфигурирование тестов Pytest в проекте 
- **Структура проекта для тестирования**: Рекомендации по организации тестов в проекте. Где лучше расположить тесты в сложных проектах?
- **Именование файлов и тестов**: Соглашения об именовании для легкого распознавания и автоматического выполнения тестов.
- **Конфигурационный файл Pytest**: Создание и настройка файла `pytest.ini` для кастомизации поведения тестов.
- **Использование тегов и маркеров**: Управление запуском тестов с помощью маркеров.
- **Интеграция с IDE и системами контроля версий**: Настройка среды разработки и VCS для удобства работы с тестами.

#### Основные концепции Pytest
- **Фикстуры**: Создание и использование фикстур для инициализации тестового окружения.
- **Параметризация тестов**: Выполнение тестов с различными наборами данных.
- **Маркеры**: Применение маркеров для выборочного запуска тестов.
- **Конфигурация тестов**: Настройка поведения тестов через конфигурационные файлы.
- **Плагины**: Расширение функциональности с помощью плагинов Pytest.

#### Мокирование с Py-Mock Pytest
- **Введение в мокирование**: Понимание концепции и преимуществ мокирования.
- **Создание моков**: Использование `py-mock` для создания и настройки мок-объектов.
- **Инспекция моков**: Проверка, как и когда моки были вызваны.
- **Мокирование сложных объектов**: Техники мокирования функций, классов и других объектов.
- **Интеграция с Pytest**: Совместное использование `py-mock` и `pytest` для улучшения тестов.

#### Тестирование классов и методов с Pytest
- **Структура класса для тестирования**: Как организовать классы и методы для удобства тестирования.
- **Тестирование конструкторов и инициализации**: Проверка корректности создания объектов класса.
- **Тестирование методов класса**: Написание тестов для публичных и приватных методов.
- **Мокирование внутренних вызовов**: Использование моков для тестирования взаимодействия внутри класса.
- **Тестирование исключений**: Подходы к тестированию методов, генерирующих исключения.

#### Продвинутые темы и лучшие практики Pytest
- **Параллельное выполнение тестов**: Ускорение тестирования за счет параллельного запуска.
- **Тестирование веб-приложений**: Особенности тестирования веб-приложений с помощью Pytest.
- **Работа с базами данных**: Стратегии и практики тестирования кода, взаимодействующего с базами данных.
- **CI/CD интеграция**: Автоматизация тестирования в процессах непрерывной интеграции и доставки.
- **Лучшие практики написания тестов**: Рекомендации для написания читаемых, поддерживаемых и эффективных тестов.

## Пирамида тестирования

![[slide-8.jpg]]
![[f703d857f224313407eeddaf68de663f.png]]



давайте рассмотрим обе представленные диаграммы и обсудим их. Обе изображают тестовую пирамиду, которая демонстрирует распределение различных типов тестирования в идеальном тестовом портфеле.

Первая пирамида (с облаком вверху) отражает следующую иерархию:

1. **Ручные тесты (Manual Tests)** – самый верхний уровень. Они включают действия тестировщиков, которые вручную проверяют функциональность продукта, чтобы убедиться, что он работает как предполагается. Этот тип тестирования обычно требует больше времени и ресурсов.
    
2. **Автоматизированные GUI тесты (Automated GUI Tests)** – тесты, которые автоматически выполняются с использованием инструментов для имитации взаимодействия пользователя с графическим интерфейсом.
    
3. **Интеграционные тесты (Integration Tests)** – проверка взаимодействия между различными модулями или сервисами в приложении, чтобы убедиться, что они работают корректно вместе.
    
4. **Юнит-тесты (Unit Tests)** – самый нижний уровень, он включает в себя тестирование отдельных компонентов или модулей кода, являясь наиболее детальным уровнем тестирования.
    

Вторая пирамида отображает те же уровни, но без облака, и на русском языке. Обычно "правильность" пирамиды определяется не формой, а соотношением объема тестов на каждом уровне: юнит-тестов должно быть больше, чем интеграционных, и т.д., поскольку это позволяет более быстро и эффективно находить и устранять ошибки.

Теперь, касательно того, как это можно реализовать в проекте на Pytest:

- **Юнит-тесты** – Pytest идеально подходит для написания и выполнения юнит-тестов. Вы можете тестировать функции и классы в изоляции, мокая зависимости при необходимости.
    
- **Интеграционные тесты** – используя Pytest, можно проверять, как различные части системы работают вместе. Это может включать тестирование взаимодействия с базами данных, веб-сервисами и другими внешними системами.
    
- **Автоматизированные GUI тесты** – хотя Pytest не предназначен для тестирования GUI напрямую, его можно интегрировать с инструментами, такими как Selenium, для автоматизации тестирования веб-интерфейсов.
    
- **Ручные тесты** – Pytest не применяется для ручного тестирования, но он может помочь документировать и отслеживать результаты ручных тестов через специализированные плагины или отчеты.
    

Юнит-тестирование является фундаментом тестовой пирамиды, так как оно позволяет быстро и эффективно выявлять базовые проблемы в коде, в то время как более высокие уровни пирамиды позволяют обеспечить более комплексную проверку взаимодействия компонентов системы и её работы в целом.


## 1. Введение в Pytest (без кода) 🐍

## 2. Обзор Pytest: Что такое Pytest и почему он популярен среди разработчиков 💻

Pytest — это мощная библиотека для тестирования кода на Python, которая пользуется большой популярностью среди разработчиков по множеству причин. Давай рассмотрим, что это такое и почему она так популярна.

### Что такое Pytest?

**Pytest** — это фреймворк для тестирования Python-проектов. Он позволяет легко создавать простые, но мощные тесты, и поддерживает сложные функциональные тестирования для приложений и библиотек.

### Почему Pytest популярен?

1. **Простота в использовании**: Pytest очень прост в настройке и использовании. Для написания базовых тестов не требуется сложной конфигурации или дополнительного кода.
    
2. **Мощные возможности**: Несмотря на свою простоту, Pytest предлагает мощные функции, такие как поддержка параметризации, фикстур, плагинов, а также возможность легко перехватывать исключения и проверять вывод программ.
    
3. **Параметризация**: Pytest позволяет легко параметризовать тесты, что упрощает проверку функций с различными входными данными.
    
4. **Фикстуры**: Фикстуры в Pytest предоставляют мощный инструмент для настройки условий перед выполнением теста. Это может быть создание тестовой базы данных, настройка сетевых соединений или подготовка данных.
    
5. **Маркировка и выборочное тестирование**: С помощью маркеров можно легко включать или исключать тесты из запуска, что делает процесс тестирования гибким и удобным.
    
6. **Поддержка разработки через тестирование (TDD)**: Pytest отлично подходит для TDD, так как позволяет быстро написать тесты ещё до реализации функциональности.
    
7. **Отличное сообщество и плагины**: Существует множество плагинов, расширяющих возможности Pytest, а также активное сообщество, готовое помочь с вопросами и проблемами.
    
8. **Интеграция с другими системами**: Pytest легко интегрируется с системами непрерывной интеграции и доставки, такими как Jenkins, Travis CI и другими.

## 3. Сравнение Pytest и Unittest: Преимущества и недостатки ⚖️

Pytest и Unittest — два популярных инструмента для тестирования кода на Python. Оба они имеют свои преимущества и недостатки, и выбор между ними часто зависит от личных предпочтений разработчика и специфики проекта. Давай сравним их.

### Pytest:

#### Преимущества 👍:
1. **Простота написания тестов**: Тесты могут быть более компактными, поскольку не требуют классов и методов, как в Unittest.
2. **Параметризация тестов**: Pytest позволяет легко параметризовать тесты, что делает их более мощными и гибкими.
3. **Фикстуры**: Мощная система фикстур предлагает гибкий способ настройки и разделения кода подготовки данных и условий.
4. **Плагины и сообщество**: Большое количество доступных плагинов и активное сообщество.
5. **Улучшенные сообщения об ошибках**: Pytest предоставляет более информативные сообщения об ошибках, что упрощает отладку.
6. **Маркировка и выборочное тестирование**: Возможность легко включать и исключать тесты из запуска.

#### Недостатки 👎:
1. **Кривая обучения**: Для новичков может быть сложнее начать работу с Pytest из-за большого количества функций и возможностей.
2. **Зависимость от стороннего инструмента**: В отличие от Unittest, Pytest не входит в стандартную библиотеку Python.

### Unittest:

#### Преимущества 👍:
1. **Стандартная библиотека**: Unittest входит в стандартную библиотеку Python, что означает, что для его использования не требуется устанавливать дополнительные пакеты.
2. **Понятная организация**: Тесты организованы в классы и методы, что может быть более понятно для разработчиков с опытом работы в объектно-ориентированных языках.
3. **Хорошо документирован**: Поскольку Unittest давно существует, он имеет обширную документацию и множество руководств.
4. **Поддержка тестовых наборов**: Возможность создавать тестовые наборы для организации и запуска тестов.

#### Недостатки 👎:
1. **Более многословный**: Тесты часто требуют больше шаблонного кода по сравнению с Pytest.
2. **Ограниченные возможности по сравнению с Pytest**: Нет таких продвинутых функций, как параметризация или мощные фикстуры.
3. **Сообщения об ошибках могут быть менее информативными**: В отличие от Pytest, Unittest может предоставлять менее подробные сообщения об ошибках.

### Заключение:

Выбор между Pytest и Unittest во многом зависит от личных предпочтений, опыта и требований проекта. **Pytest** предлагает более современный подход и обширные возможности, что делает его популярным выбором в сообществе Python. **Unittest**, будучи частью стандартной библиотеки, предлагает более традиционный и структурированный подход к тестированию. Оба инструмента способны обеспечить надёжное и эффективное тестирование ваших Python-проектов.

## 4. Установка Pytest: Пошаговая инструкция по установке и настройке 📥

Установка Pytest очень проста. Если на вашем компьютере установлен Python и pip (менеджер пакетов Python), выполните следующую команду:

```sh
pip install pytest
```

После этого Pytest будет установлен и готов к использованию. Обновление pytest осуществляется командой:

```sh
pip install -U pytest
```

## 5.Первый тест с Pytest: Написание и выполнение простого теста ⌨️

В Pytest `assert` — это ключевое слово Python, используемое для проверки утверждений в тестах. Если выражение после `assert` истинно, тест проходит, если ложно — тест проваливается, и Pytest выводит сообщение об ошибке.

### Простой пример теста с `assert`:

```python
# test_example.py

def test_true():
    assert True  # Этот тест пройдет, так как True всегда истинно.
```

Если запустить этот тест с помощью Pytest, он пройдет без ошибок, потому что утверждение истинно.

### Вывод сообщения о провале теста:

Pytest автоматически выводит сообщение о провале теста, если `assert` не выполняется. Вы также можете добавить своё сообщение, чтобы сделать результаты более информативными.

```python
# test_failure.py

def test_false():
    assert False, "Тест провален, так как False является ложным"
```

Если запустить этот тест, Pytest выведет сообщение "Тест провален, так как False является ложным", указывая на то, что тест не прошел.

### Пример теста с простой функцией, которую импортируют:

Допустим, у вас есть файл `math_functions.py` с функцией `add`, и вы хотите написать для неё тест.

**math_functions.py:**
```python
# math_functions.py

def add(a, b):
    return a + b
```

**test_math_functions.py:**
```python
# test_math_functions.py
from math_functions import add

def test_add():
    assert add(2, 3) == 5, "Тест провален, add(2, 3) не равно 5"
```

Здесь функция `add` импортируется из файла `math_functions.py`. Тест `test_add` проверяет, верно ли функция складывает два числа. Если результат будет другим, Pytest выведет сообщение "Тест провален, add(2, 3) не равно 5".

Запуск тестов выполняется командой `pytest` в терминале. Если функция работает правильно, тест пройдет, иначе Pytest выведет сообщение об ошибке с указанием, какой именно тест провалился и почему. Это помогает разработчикам быстро идентифицировать и устранять проблемы в коде.

## 6. Основы утверждений: Как использовать утверждения для проверки результатов ✅

В Pytest утверждения пишутся простым и понятным образом с использованием конструкции `assert`. Вот несколько примеров:

```python
def test_numbers():
    assert 1 + 1 == 2
    assert 2 * 2 == 4
    assert 10 / 2 == 5

def test_strings():
    assert "pytest".upper() == "PYTEST"
    assert "python".startswith("py")
    assert "Hello, world!".split() == ["Hello,", "world!"]
```

Использование утверждений (`assertions`) в тестах — это мощный способ проверки того, что ваш код работает так, как ожидается. Утверждения проверяют, истинно ли заданное выражение, и если нет — тест считается проваленным. Вот как ты можешь использовать утверждения для проверки результатов в Python и, в частности, в Pytest.

### Основы утверждений в Python:

В Python ключевое слово `assert` используется для утверждений. Синтаксис прост:

```python
assert условие, сообщение_об_ошибке
```

- **условие**: выражение, которое проверяется. Если оно оценивается как `True`, тест проходит.
- **сообщение_об_ошибке**: необязательное сообщение, которое выводится, если условие ложно.

### Примеры использования утверждений:

**1. Проверка равенства:**

```python
def test_addition():
    result = 1 + 1
    assert result == 2, "1 + 1 должно быть 2"
```

**2. Проверка, что элемент находится в списке:**

```python
def test_in_list():
    my_list = [1, 2, 3, 4, 5]
    assert 3 in my_list, "3 должно быть в списке"
```

**3. Проверка, что объект не `None`:**

```python
def test_not_none():
    my_value = some_function_that_shouldnt_return_none()
    assert my_value is not None, "my_value не должно быть None"
```

### Использование утверждений в Pytest:

Pytest улучшает встроенные утверждения Python, предоставляя более информативные сообщения об ошибках и дополнительные возможности. В Pytest ты используешь утверждения так же, как и в обычном Python, но получаешь дополнительные преимущества:

**1. Автоматическое обнаружение тестов:** Pytest автоматически находит функции, начинающиеся на `test_`, и запускает их как тесты.

**2. Расширенные сообщения об ошибках:** При провале теста Pytest предоставляет подробный контекст, что помогает быстрее понять причину.

### Примеры:

**Тест с использованием Pytest:**

```python
# test_example.py
from some_module import subtract

def test_subtract():
    assert subtract(5, 3) == 2, "Вычитание 5 - 3 должно быть равно 2"
```

**Запуск тестов:**

В терминале ты бы запустил свои тесты командой `pytest`. Если утверждение не выполнится, Pytest выведет сообщение об ошибке, указанное в утверждении, вместе с подробным описанием того, что пошло не так.

### Лучшие практики:

1. **Делайте утверждения конкретными:** Чем точнее утверждение, тем лучше. Следует избегать общих утверждений, таких как `assert True`.

2. **Используйте сообщения об ошибках:** Всегда предоставляйте информативные сообщения об ошибках, чтобы было понятно, почему тест провалился.

3. **Один тест — одно утверждение:** Хотя иногда это не всегда возможно или практично, стремитесь проверять один аспект поведения в каждом тесте.

Используя эти основы и практики, ты сможешь эффективно использовать утверждения для проверки результатов своих тестов, убедившись, что твой код работает правильно и надежно.


## 7. Работа с результатами: Понимание вывода тестов и отчетов 📊

Понимание вывода тестов и отчетов в Pytest — ключевой навык для эффективного разрешения проблем и улучшения качества кода. Когда ты запускаешь тесты с Pytest, он предоставляет подробные отчеты о результатах, указывая, какие тесты прошли успешно, какие провалились, и почему. Вот как ты можешь интерпретировать эти результаты:

### 1. Основы вывода Pytest:

При запуске тестов, Pytest выводит информацию в следующем формате:

- `.` (точка): Тест прошел успешно.
- `F`: Тест провалился (failure).
- `E`: Ошибка в тесте (error), обычно связана с исключениями, которые не были обработаны в тесте.
- `S`: Тест пропущен (skipped), обычно из-за условия, указанного в декораторе `@pytest.mark.skip`.
- `X`: Тест помечен как ожидаемо провальный (xfailed).
- `XPASS`: Тест был помечен как ожидаемо провальный, но прошел (unexpectedly passing).

### 2. Подробные отчеты о проваленных тестах:

Для каждого проваленного теста Pytest предоставляет подробный отчет, который включает:

- **Название теста**: Показывает, какой тест провалился.
- **Путь к файлу**: Указывает местоположение тестового файла.
- **Сообщение об ошибке**: Предоставляет информацию об исключении или о том, почему утверждение было ложным.
- **Трассировка стека**: Показывает последовательность вызовов, которая привела к ошибке, помогая локализовать источник проблемы.

### 3. Сводка результатов:

В конце тестовой сессии Pytest выводит сводку, включающую:

- **Общее количество тестов**: Сколько тестов было выполнено.
- **Количество ошибок и провалов**: Сколько тестов провалилось или завершилось ошибкой.
- **Пропущенные и ожидаемо провальные тесты**: Сколько тестов было пропущено или помечено как ожидаемо провальные.

### 4. Работа с отчетами:

Для более подробного анализа ты можешь использовать различные опции командной строки Pytest:

- `-v, --verbose`: Предоставляет более подробный вывод.
- `--tb=style`: Управляет стилем трассировки стека (например, `short`, `long`, `no`).
- `-r`: Дает возможность получать дополнительные сведения о конкретных типах результатов тестов (например, `-rF` для получения подробной информации о проваленных тестах).
- `--junitxml=path`: Генерирует отчеты в формате XML для интеграции с системами непрерывной интеграции.

### 5. Примеры и интерпретация:

**Пример успешного теста:**

```
test_example.py .                                                           [100%]
```

**Пример проваленного теста:**

```
test_example.py F                                                           [100%]

================================== FAILURES ===================================
______________________________ test_example_fail ______________________________

    def test_example_fail():
>       assert 1 == 2, "Число 1 не равно 2"
E       AssertionError: Число 1 не равно 2
E       assert 1 == 2

test_example.py:3: AssertionError
```

**Интерпретация**: Тест `test_example_fail` провалился, потому что утверждение `1 == 2` ложно. Сообщение об ошибке `Число 1 не равно 2` помогает понять причину провала.


### Сводная таблица флагов 

Вот сводная таблица некоторых наиболее часто используемых флагов командной строки и их популярных комбинаций для запуска тестов с использованием Pytest. Эти флаги помогают управлять поведением тестов и выводом результатов.

### Основные флаги:

| Флаг                     | Описание                                                                       |
| ------------------------ | ------------------------------------------------------------------------------ |
| `-v`, `--verbose`        | Увеличивает детализацию вывода, показывая названия всех тестов.                |
| `-q`, `--quiet`          | Уменьшает детализацию вывода.                                                  |
| `--tb=style`             | Устанавливает стиль трассировки стека (`long`, `short`, `line`, `no`).         |
| `-x`, `--exitfirst`      | Прекращает тестирование после первого же провала.                              |
| `--ff`, `--failed-first` | Сначала запускает последние проваленные тесты, затем все остальные.            |
| `--lf`, `--last-failed`  | Запускает только те тесты, которые провалились в последний раз.                |
| `--maxfail=num`          | Прекращает тестирование после заданного количества провалов.                   |
| `-k`                     | Запускает тесты, соответствующие данному выражению.                            |
| `-m`                     | Запускает тесты с определенной маркировкой.                                    |
| `--junitxml=path`        | Создает отчет о тестах в формате XML в указанном месте.                        |
| `--setup-show`           | Показывает подробности о настройке и завершении работы фикстур.                |
| `-s`, `--capture=no`     | Отключает перехват вывода, позволяя видеть вывод в консоли в реальном времени. |
| `--durations=N`          | Показывает N самых медленных тестов после выполнения.                          |

### Популярные комбинации флагов:

**1. Вербозный режим с остановкой после первой ошибки:**
- Комбинация: `pytest -v -x`
- Описание: Показывает подробные названия тестов и останавливается после первого провала.

**2. Только последние проваленные тесты:**
- Комбинация: `pytest --lf`
- Описание: Запускает только те тесты, которые провалились в последнем запуске.

**3. Запуск тестов с определенной маркировкой:**
- Комбинация: `pytest -m markername`
- Описание: Запускает только тесты с указанной маркировкой.

**4. Генерация отчета в формате XML:**
- Комбинация: `pytest --junitxml=path/to/report.xml`
- Описание: Сохраняет результаты тестов в файл XML для интеграции с CI/CD системами.

**5. Подробный вывод с отключением перехвата вывода:**
- Комбинация: `pytest -v -s`
- Описание: Показывает подробные названия тестов и позволяет видеть вывод в консоли в реальном времени.

Эти флаги и комбинации могут значительно упростить и ускорить процесс тестирования, предоставляя больше контроля над запуском и анализом тестов, мой юный падаван!
## 1. Размещение и конфигурирование тестов Pytest в проекте 📝

## 1.1. Структура проекта для тестирования 🌳

Существует несколько подходов к организации тестов в проекте. В небольших проектах распространен подход, когда все тесты находятся в папке `tests` на одном уровне с основным кодом проекта. В более сложных проектах рекомендуется создать отдельную ветку папок `tests`, зеркально повторяющую структуру основного кода проекта.

Пример простой структуры проекта:

```
my_project/
    ├── my_module.py
    └── tests/
        └── test_my_module.py
```

Пример структуры для сложного проекта:

```
my_project/
    ├── src/
    │   ├── my_pkg1/
    │   │   ├── __init__.py
    │   │   └── module1.py
    │   └── my_pkg2/
    │       ├── __init__.py
    │       └── module2.py
    └── tests/
        ├── test_pkg1/
        │   ├── __init__.py
        │   └── test_module1.py
        └── test_pkg2/
            ├── __init__.py
            └── test_module2.py
```

## 1.2. Именование файлов и тестов ✏️

Согласно соглашениям Pytest, названия файлов с тестами должны начинаться на `test_` или заканчиваться на `_test`. Кроме того, все функции и классы с тестами должны начинаться с `test_`. 

Примеры:

```python
# test_my_module.py

def test_some_function():
    pass

class TestSomeClass:
    def test_method(self):
        pass
```

### Файлы, воспринимаемые как тестовые:

- **Имена файлов**: По умолчанию Pytest ищет файлы, названия которых начинаются на `test_` или заканчиваются на `_test.py`. Например, `test_example.py` или `example_test.py`.

### Функции, воспринимаемые как тестовые:

- **Имена функций**: Функции, которые считаются тестами, обычно начинаются со слова `test`. Например, функция с именем `test_myfunction()` будет распознана как тест.
    
- **Имена классов**: Если ты используешь классы для организации тестов, Pytest ищет классы, начинающиеся с `Test`, при условии, что у них нет инициализатора `__init__`. Методы внутри этих классов, соответствующие именованию тестовых функций, будут запущены как тесты.


### О Важности пакетов

В Python, чтобы папка считалась пакетом, в ней должен находиться файл `__init__.py`. Этот файл может быть пустым, но его наличие указывает интерпретатору Python, что он может импортировать модули (питоновские файлы `.py`) из этой директории как части пакета.

**Вот несколько причин, почему это важно:**

1. **Пространство имён (Namespace)**: Пакеты в Python создают пространство имён, которое предотвращает конфликты имен между модулями. Благодаря этому ты можешь иметь модули с одинаковыми именами в разных пакетах без риска коллизий.
    
2. **Импорт модулей**: Если ты попытаешься импортировать модуль из папки, которая не является пакетом (то есть не содержит `__init__.py`), Python не сможет найти этот модуль и выдаст ошибку `ModuleNotFoundError`. Это связано с тем, что папки без файла `__init__.py` не включаются в `sys.path` — список директорий, которые интерпретатор Python просматривает при импорте модулей.
    
3. **Тестирование**: Когда ты используешь фреймворк для тестирования, такой как Pytest, он ищет тесты в пакетах. Если папка с тестами не является пакетом, Pytest может не найти и не выполнить тесты. Делая папку с тестами пакетом, ты гарантируешь, что тесты можно будет легко импортировать и запускать.
    
4. **Упаковка и распространение**: Пакеты можно легко упаковывать и распространять с помощью инструментов вроде setuptools. Это удобно, если ты планируешь делиться своим кодом с другими пользователями Python или развертывать его в производственной среде.
    

**Что делать, если ты не хочешь, чтобы папка была пакетом?**

Иногда бывают случаи, когда тебе нужно выполнить скрипты Python, которые находятся в папке, не являющейся пакетом. В таких ситуациях можно использовать различные приёмы для модификации `sys.path`, чтобы добавить нужные директории в путь поиска модулей. Однако это менее предпочтительно и может привести к проблемам с зависимостями и неожиданному поведению при импорте модулей.

В контексте тестирования и Pytest, лучше всего структурировать твои тесты и код, которые ты тестируешь, в виде пакетов, чтобы обеспечить безопасность импорта и избежать подобных проблем.
## 1.3. Конфигурационный файл Pytest ⚙️

Конфигурационный файл Pytest и использование тегов и маркеров играют важную роль в управлении и организации тестов. Вот как ты можешь их использовать для повышения эффективности тестирования:

### Конфигурационный файл Pytest (pytest.ini, tox.ini, pyproject.toml)

**1. Описание:**
Конфигурационный файл используется для определения настроек и параметров по умолчанию для Pytest. Это может включать определение стандартных опций командной строки, настройку путей к тестам, конфигурацию плагинов и многое другое.

**2. Примеры настроек:**

- `pytest.ini`:
    ```ini
    [pytest]
    minversion = 6.0
    addopts = -ra -q
    testpaths =
        tests
    markers =
        slow: marks tests as slow (deselect with '-m "not slow"')
        serial
    ```

- `pyproject.toml`:
    ```toml
    [tool.pytest.ini_options]
    minversion = "6.0"
    addopts = "-ra -q"
    testpaths = [
        "tests",
    ]
    markers = [
        "slow: marks tests as slow (deselect with '-m \"not slow\"')",
        "serial",
    ]
    
```
### Использование тегов и маркеров:

**1. Маркеры:**
Маркеры в Pytest - это способ классифицировать тесты по определенным признакам, таким как `slow`, `fast`, `requires_db` и так далее. Они позволяют легко включать или исключать группы тестов при выполнении.

**2. Добавление маркера:**
Чтобы использовать маркер, сначала добавь его в конфигурационный файл, чтобы избежать предупреждений о незарегистрированных маркерах:

```ini
[pytest]
markers =
    slow: Marks tests as slow.
```

**3. Применение маркера к тесту:**
```python
import pytest

@pytest.mark.slow
def test_example_slow():
    pass  # ваш медленный код здесь
```

**4. Запуск тестов с маркерами:**
- Запуск только медленных тестов: `pytest -v -m slow`
- Исключение медленных тестов: `pytest -v -m "not slow"`

один тест может принадлежать нескольким маркерам в Pytest, и это довольно распространенная практика для детализации и гибкой настройки тестов. Вот как ты можешь это сделать:

### Назначение нескольких маркеров одному тесту:

Ты можешь применить несколько маркеров к одному тесту, просто декорируя его несколькими маркерами:

```python
import pytest

@pytest.mark.slow
@pytest.mark.regression
def test_example():
    # твой тестовый код здесь
    assert True
```

В этом примере тест `test_example` отмечен как `slow` и `regression`.

### Запуск тестов с несколькими маркерами:

Ты можешь запускать тесты с определенными маркерами, используя параметр `-m` при вызове Pytest. Если ты хочешь запустить тесты, которые соответствуют нескольким маркерам, используй логические операторы.

- **Использование 'and' (и)**: Запускает тесты, которые отмечены всеми указанными маркерами.

  ```bash
  pytest -m "marker1 and marker2"
  ```

- **Использование 'or' (или)**: Запускает тесты, которые отмечены хотя бы одним из указанных маркеров.

  ```bash
  pytest -m "marker1 or marker2"
  ```

- **Использование 'not' (не)**: Исключает тесты, отмеченные указанным маркером.

  ```bash
  pytest -m "not marker1"
  ```

### Пример:

Допустим, у тебя есть следующие тесты:

```python
import pytest

@pytest.mark.slow
def test_slow_1():
    assert True

@pytest.mark.fast
def test_fast():
    assert True

@pytest.mark.slow
@pytest.mark.regression
def test_slow_regression():
    assert True
```

- Чтобы запустить только тесты, отмеченные как `slow` и `regression` одновременно, используй:

  ```bash
  pytest -m "slow and regression"
  ```

- Чтобы запустить тесты, отмеченные как `slow` или `fast`, используй:

  ```bash
  pytest -m "slow or fast"
  ```

### Преимущества использования конфигурационных файлов и маркеров:

- **Повышенная гибкость**: Можно легко настроить тестовую среду и параметры запуска.
- **Улучшенная организация**: Тесты могут быть классифицированы и группированы по функциям, скорости исполнения или любым другим критериям.
- **Эффективное управление**: Легко включать или исключать тесты при запуске, что упрощает работу с большими наборами тестов и различными сценариями тестирования.
- **Стандартизация настроек**: Общие настройки и параметры могут быть определены в одном месте, обеспечивая согласованность и упрощение поддержки.

Используя эти инструменты, ты сможешь значительно повысить эффективность и удобство тестирования своих проектов на Python, мой юный падаван!

Другие параметры можно найти в [официальной документации](https://docs.pytest.org/en/6.2.x/customize.html#ini-options-ref).

## 1.4. Использование тегов и маркеров 🏷️

Маркеры помогают управлять запуском тестов, выбирая только определенные и исключая другие. 

Пример использования маркера в коде теста:

```python
import pytest

@pytest.mark.experimental
def test_experimental_feature():
    pass
```

Запуск тестов с определенным маркером:

```
pytest -m experimental
```

Исключение тестов с заданным маркером:

```
pytest -m "not experimental"
```

**Важно!** Зарегистрируйте используемые маркеры в файле `pytest.ini`:

```ini
[pytest]
markers =
    experimental: marks tests as experimental
```

## 1.5. Интеграция с IDE и системами контроля версий 🔗

### 1. **Интеграция с инструментами CI/CD:**

CI/CD инструменты, такие как Jenkins, Travis CI, CircleCI и GitLab CI, часто используют XML отчеты для определения результатов тестирования. Эти системы могут автоматически считывать файлы XML и предоставлять подробные отчеты о результатах тестирования прямо в интерфейсе CI/CD, что упрощает анализ и отслеживание проблем.

### 2. **Визуализация результатов:**

Файлы XML можно использовать для создания визуализаций и сводных отчетов о результатах тестирования. Это может включать количество проваленных и успешных тестов, время выполнения тестов и другую полезную информацию. Визуальное представление делает результаты более понятными и помогает командам быстро определять тенденции и проблемные области.

### 3. **Отслеживание истории и анализ тенденций:**

Сохранение результатов каждого тестового запуска в файле XML позволяет анализировать историю и тенденции прохождения тестов со временем. Это может помочь выявить нестабильные тесты, повторяющиеся проблемы и другие важные аспекты, которые влияют на качество и надежность программного обеспечения.

### 4. **Улучшенное уведомление и отчетность:**

Интеграция с CI/CD и использование XML отчетов могут улучшить процессы уведомления и отчетности. Команды могут настроить системы таким образом, чтобы они автоматически информировали заинтересованных лиц о результатах тестов, особенно если тесты выявили важные проблемы, требующие немедленного внимания.

### 5. **Стандартизация результатов:**

Формат XML является стандартизированным, и его можно легко читать и обрабатывать различными инструментами и системами. Это обеспечивает согласованность и совместимость при работе с различными инструментами и платформами.

### Заключение:

Использование Pytest для сохранения результатов тестов в файл XML и интеграция с системами CI/CD значительно повышает эффективность процесса разработки. Оно обеспечивает быстрое обнаружение и устранение ошибок, повышает прозрачность процесса тестирования и помогает поддерживать высокое качество кода,


интеграция Pytest с IDE, такой как PyCharm, и системами контроля версий, такими как Git, может значительно улучшить процесс разработки и тестирования. Вот как ты можешь настроить и использовать Pytest в PyCharm и интегрировать его с системами контроля версий.

### Интеграция Pytest с PyCharm:

**1. Установка Pytest:**
Убедись, что Pytest установлен в твоем виртуальном окружении. Это можно сделать через терминал с помощью команды `pip install pytest` или через менеджер пакетов PyCharm.

**2. Настройка интерпретатора:**
- Открой настройки PyCharm (`File > Settings` или `PyCharm > Preferences` на Mac).
- Перейди в раздел `Project: [твой проект] > Project Interpreter`.
- Убедись, что активировано нужное виртуальное окружение, в котором установлен Pytest.

**3. Конфигурирование тестов:**
- Перейди в `File > Settings > Tools > Python Integrated Tools`.
- В разделе `Testing`, выбери Pytest в качестве тестового фреймворка.
- Примени изменения.

**4. Создание конфигурации запуска тестов:**
- Открой тест или тестовый файл, который хочешь запустить.
- Справа в верхнем углу нажми на выпадающее меню рядом с кнопкой зеленого треугольника (запуск) и выбери 'Edit Configurations'.
- Нажми на '+' и выбери 'Python tests > pytest'.
- Настрой параметры запуска по своему усмотрению (например, добавь аргументы командной строки Pytest).
- Сохрани конфигурацию.

Теперь ты можешь запускать и отлаживать тесты Pytest прямо из PyCharm, используя созданную конфигурацию.

### Конфигурационный файл Pytest в PyCharm:

PyCharm автоматически учитывает настройки из файла `pytest.ini`, если он находится в корневой директории проекта. В этом файле ты можешь определить различные параметры и настройки Pytest, такие как параметры командной строки по умолчанию, пути к тестам, маркеры и другое.

### Интеграция с системами контроля версий:

**1. Git и другие системы:**
- Используй систему контроля версий, чтобы отслеживать изменения в тестах и конфигурационных файлах.
- Настраивай хуки Git для запуска тестов перед коммитами или пушами, чтобы убедиться, что изменения не нарушают существующий функционал.

**2. CI/CD инструменты:**
- Интегрируй свой проект с инструментами непрерывной интеграции/непрерывной доставки, такими как Jenkins, Travis CI, GitLab CI и другими.
- Настрой запуск тестов Pytest в рамках пайплайна CI/CD, чтобы автоматически выполнять тесты при каждом коммите или пуше в репозиторий.

Используя эти методы, ты сможешь эффективно интегрировать Pytest в свой рабочий процесс разработки и тестирования, обеспечивая высокое качество и стабильность кода.

### Разные форматы для конфигурационного файла.

интеграция Pytest с IDE, такой как PyCharm, и системами контроля версий, такими как Git, может значительно улучшить процесс разработки и тестирования. Вот как ты можешь настроить и использовать Pytest в PyCharm и интегрировать его с системами контроля версий.

### Интеграция Pytest с PyCharm:

**1. Установка Pytest:**
Убедись, что Pytest установлен в твоем виртуальном окружении. Это можно сделать через терминал с помощью команды `pip install pytest` или через менеджер пакетов PyCharm.

**2. Настройка интерпретатора:**
- Открой настройки PyCharm (`File > Settings` или `PyCharm > Preferences` на Mac).
- Перейди в раздел `Project: [твой проект] > Project Interpreter`.
- Убедись, что активировано нужное виртуальное окружение, в котором установлен Pytest.

**3. Конфигурирование тестов:**
- Перейди в `File > Settings > Tools > Python Integrated Tools`.
- В разделе `Testing`, выбери Pytest в качестве тестового фреймворка.
- Примени изменения.

**4. Создание конфигурации запуска тестов:**
- Открой тест или тестовый файл, который хочешь запустить.
- Справа в верхнем углу нажми на выпадающее меню рядом с кнопкой зеленого треугольника (запуск) и выбери 'Edit Configurations'.
- Нажми на '+' и выбери 'Python tests > pytest'.
- Настрой параметры запуска по своему усмотрению (например, добавь аргументы командной строки Pytest).
- Сохрани конфигурацию.

Теперь ты можешь запускать и отлаживать тесты Pytest прямо из PyCharm, используя созданную конфигурацию.

### Конфигурационный файл Pytest в PyCharm:

PyCharm автоматически учитывает настройки из файла `pytest.ini`, если он находится в корневой директории проекта. В этом файле ты можешь определить различные параметры и настройки Pytest, такие как параметры командной строки по умолчанию, пути к тестам, маркеры и другое.

### Интеграция с системами контроля версий:

**1. Git и другие системы:**
- Используй систему контроля версий, чтобы отслеживать изменения в тестах и конфигурационных файлах.
- Настраивай хуки Git для запуска тестов перед коммитами или пушами, чтобы убедиться, что изменения не нарушают существующий функционал.

**2. CI/CD инструменты:**
- Интегрируй свой проект с инструментами непрерывной интеграции/непрерывной доставки, такими как Jenkins, Travis CI, GitLab CI и другими.
- Настрой запуск тестов Pytest в рамках пайплайна CI/CD, чтобы автоматически выполнять тесты при каждом коммите или пуше в репозиторий.

Используя эти методы, ты сможешь эффективно интегрировать Pytest в свой рабочий процесс разработки и тестирования, обеспечивая высокое качество и стабильность кода


### Сводная таблица параметров `pytest.ini`
Вот таблица с основными параметрами, которые следует знать для конфигурирования тестов в `pytest.ini`. Эти параметры помогут тебе настроить поведение Pytest под конкретные нужды твоего проекта:

| Название параметра | Что он делает                                                                 | Пример синтаксиса                      |
|-------------------|-------------------------------------------------------------------------------|----------------------------------------|
| `addopts`         | Добавляет дополнительные аргументы командной строки по умолчанию.            | `addopts = -v -ra --maxfail=2`         |
| `testpaths`       | Указывает директории, в которых Pytest будет искать тесты.                    | `testpaths = tests`                    |
| `python_files`    | Определяет шаблоны имен файлов, которые Pytest будет распознавать как тесты. | `python_files = test_*.py`             |
| `python_classes`  | Указывает шаблоны имен классов, которые Pytest будет считать тестовыми.      | `python_classes = Test*`               |
| `python_functions`| Определяет шаблоны имен функций, которые Pytest будет считать тестами.       | `python_functions = test_*`            |
| `markers`         | Определяет пользовательские маркеры, которые можно использовать в тестах.    | `markers = slow: mark tests as slow`   |
| `usefixtures`     | Предварительно применяет фикстуры ко всем тестам в сессии.                    | `usefixtures = myfixture`              |
| `filterwarnings`  | Настраивает фильтрацию предупреждений Python во время тестирования.          | `filterwarnings = ignore::UserWarning` |

### Пример файла pytest.ini:

```ini
# pytest.ini
[pytest]
addopts = -ra -q
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    serial: marks tests as needing to be run serially
usefixtures = myfixture
filterwarnings =
    ignore::DeprecationWarning
```

Этот пример демонстрирует, как настроить Pytest для использования определенных директорий и шаблонов для тестов, как определить пользовательские маркеры и предварительно примененные фикстуры, а также как настроить фильтрацию предупреждений. Используя этот файл конфигурации, ты можешь значительно улучшить и упростить процесс тестирования в своем проекте.

## 1. Основные концепции Pytest 📘

## 1.1. Фикстуры 🧰

Фикстуры в Pytest — это мощный инструмент, позволяющий разработчикам устанавливать предварительные условия для тестов, а также выполнять необходимую очистку после их завершения. Они предоставляют функциональность для создания тестового окружения, которое требуется для выполнения теста, и обеспечивают его удаление после того, как тест завершен.

Фикстуры в Pytest определяются с помощью специальных функций, которые могут быть использованы одним или несколькими тестами. Эти функции могут создавать данные, настраивать состояние базы данных, открывать соединения с серверами или выполнять любые другие действия, необходимые для настройки тестового окружения. После завершения теста фикстуры могут также заниматься очисткой: закрывать файлы, удалять временные данные, отключать соединения и так далее.

Одна из ключевых особенностей фикстур в Pytest — это их гибкость. Ты можешь определить фикстуру, которая будет выполняться один раз для всех тестов, или настроить ее так, чтобы она выполнялась перед каждым тестом отдельно. Фикстуры также могут быть параметризованы, что позволяет запускать один и тот же тест с различными условиями, без необходимости писать для каждого случая отдельный тест.

Фикстуры делают тесты более читаемыми и легко поддерживаемыми, поскольку они избавляют тестовые функции от необходимости заниматься подготовкой и очисткой данных. Это также способствует сокращению дублирования кода, поскольку одна и та же фикстура может быть использована в нескольких тестах.

В заключение, фикстуры в Pytest — это ценный инструмент для любого разработчика, который хочет создать чистый, эффективный и легко поддерживаемый код теста. Они предоставляют гибкие и мощные возможности для управления тестовым окружением и являются ключевым компонентом любого проекта, использующего автоматизированное тестирование.

Пример создания фикстуры:

```python
import pytest

@pytest.fixture
def my_fixture():
    print("Инициализация")
    yield "Данные для теста"
    print("Завершение")
```

Для использования этой фикстуры в тесте, функции достаточно добавить аргумент с названием фикстуры:

```python
def test_example(my_fixture):
    assert my_fixture == "Данные для теста"
```

Фикстуры также могут обрабатывать зависимости и управлять порядком их выполнения с помощью параметра `pytest.fixture`:

```python
@pytest.fixture
def level_one():
    return "I'm level one"

@pytest.fixture
def level_two(level_one):
    return f"{level_one}. I depend on level_one."

def test_dependency(level_two):
    assert level_two == "I'm level one. I depend on level_one."
```
Конечно, юный падаван. Давай рассмотрим фикстуры в Pytest более подробно, предоставив более понятные примеры их использования.

### Базовые фикстуры:

Давай рассмотрим простой пример использования фикстур.

**Пример 1: Фикстура для создания списка**

```python
import pytest

# Определение фикстуры
@pytest.fixture
def sample_list():
    # Создание списка
    return [1, 2, 3, 4, 5]

# Тест, использующий фикстуру
def test_sum(sample_list):
    assert sum(sample_list) == 15
```

В этом примере, фикстура `sample_list` создает список чисел. Этот список затем используется в функции `test_sum` для проверки, что сумма элементов списка равна 15.

**Пример 2: Фикстура с использованием `yield`**

Иногда тебе нужно выполнить некоторый код после тестов для очистки или закрытия ресурсов. В таких случаях используется ключевое слово `yield`.

```python
import pytest

# Определение фикстуры с использованием yield
@pytest.fixture
def sample_data():
    data = {'python': 'advanced', 'pytest': 'cool'}
    # Код до yield выполняется перед тестом
    yield data  # Предоставляет данные тесту
    # Код после yield выполняется после теста
    print("Тест завершен!")

def test_data(sample_data):
    assert sample_data['python'] == 'advanced'
```

Здесь `sample_data` предоставляет словарь для теста. После выполнения теста (после `yield`) выводится сообщение "Тест завершен!".

### Использование параметризованных фикстур:

Фикстуры могут быть параметризованы для выполнения тестов с различными наборами данных.

**Пример 3: Параметризованная фикстура**

```python
import pytest

# Определение параметризованной фикстуры
@pytest.fixture(params=[(1, 2, 3), (4, 5, 9), (10, 20, 30)])
def triple(request):
    return request.param

def test_triple_sum(triple):
    a, b, expected_sum = triple
    assert a + b == expected_sum
```

Здесь `triple` — это параметризованная фикстура, которая принимает три разных набора данных. Тест `test_triple_sum` будет запущен три раза, каждый раз с разным набором данных.

### Фикстуры с использованием внешних ресурсов:

Фикстуры часто используются для работы с внешними ресурсами, такими как файлы или соединения с базами данных.

**Пример 4: Фикстура для работы с файлом**

```python
import pytest

# Определение фикстуры для работы с файлом
@pytest.fixture
def sample_file(tmp_path):
    file = tmp_path / "sample.txt"
    file.write_text("content")
    return file

def test_file_content(sample_file):
    assert sample_file.read_text() == "content"
```

В этом примере, `sample_file` создает временный файл с некоторым содержимым. Тест `test_file_content` проверяет, что содержимое файла соответствует ожидаемому.

### Пример фикстуры для работы с JSON файлом

Давай создадим простой пример, где мы будем тестировать функции записи и чтения JSON-файла. Предположим, у тебя есть две функции: одна записывает данные в JSON-файл, а другая читает данные из этого файла.

### Шаг 1: Функции для тестирования

Допустим, у тебя есть следующий код в файле `app.py`:

```python
import json

def write_json(data, filename):
    with open(filename, 'w') as file:
        json.dump(data, file)

def read_json(filename):
    with open(filename) as file:
        return json.load(file)
```

### Шаг 2: Тесты с использованием Pytest и фикстур

Создадим тесты в файле `test_app.py`:

```python
import json
import os
import pytest
from app import write_json, read_json

# Фикстура для создания временного файла
@pytest.fixture
def temp_file(tmp_path):
    return tmp_path / "temp_file.json"

# Тест функции записи JSON
def test_write_json(temp_file):
    data = {"key": "value"}
    write_json(data, temp_file)
    # Проверяем, что файл существует и содержимое правильное
    assert temp_file.exists()
    with open(temp_file) as f:
        assert json.load(f) == data

# Тест функции чтения JSON
def test_read_json(temp_file):
    data = {"key": "value"}
    # Сначала записываем данные для последующего чтения
    with open(temp_file, 'w') as f:
        json.dump(data, f)
    # Проверяем, что чтение возвращает правильные данные
    assert read_json(temp_file) == data
```

### Шаг 3: Запуск тестов

Теперь ты можешь запустить тесты, используя Pytest, выполнив следующую команду в терминале:

```bash
pytest test_app.py
```
### Что происходит в этих тестах?

- **Фикстура `temp_file`**: Создает временный файл, который используется для записи и чтения данных. После каждого теста Pytest автоматически удаляет этот временный файл, обеспечивая чистоту тестового окружения.
  
- **Тест `test_write_json`**: Проверяет, правильно ли функция `write_json` записывает данные в файл. Он убеждается, что файл был создан и что его содержимое соответствует ожидаемым данным.

- **Тест `test_read_json`**: Сначала записывает некоторые данные во временный файл, а затем проверяет, правильно ли функция `read_json` считывает и возвращает эти данные.

Этот простой пример демонстрирует, как можно тестировать функции работы с файлами и JSON, используя Pytest и его фикстуры для управления тестовым окружением.


### Фикстура и БД

Давай создадим простой пример теста, который работает с базой данных SQLite. Мы будем тестировать функциональность создания нового пользователя в существующей базе данных. В реальной ситуации такой тест может проверять, правильно ли приложение добавляет новую запись пользователя в базу данных.

### Шаг 1: Функции для работы с базой данных

Допустим, у тебя есть следующий код в файле `app.py`, который включает функцию для добавления пользователя в базу данных SQLite:

```python
import sqlite3

def create_user(db_path, username, email):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('CREATE TABLE IF NOT EXISTS users (username text, email text)')
    c.execute('INSERT INTO users VALUES (?,?)', (username, email))
    conn.commit()
    conn.close()

def get_user(db_path, username):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('SELECT * FROM users WHERE username=?', (username,))
    user = c.fetchone()
    conn.close()
    return user
```

### Шаг 2: Тесты с использованием Pytest и фикстур

Создадим тесты в файле `test_app.py`:

```python
import pytest
import os
from app import create_user, get_user

# Фикстура для создания временной базы данных
@pytest.fixture
def temp_db(tmp_path):
    db_path = tmp_path / "test.db"
    # Создаем пустую базу данных
    open(db_path, 'w').close()
    return db_path

# Тест создания нового пользователя
def test_create_user(temp_db):
    username = "testuser"
    email = "test@example.com"
    # Создаем нового пользователя
    create_user(temp_db, username, email)
    # Получаем пользователя из базы данных
    user = get_user(temp_db, username)
    # Проверяем, что пользователь существует и его данные корректны
    assert user == (username, email)
```

### Шаг 3: Запуск тестов

Теперь ты можешь запустить тесты, используя Pytest, выполнив следующую команду в терминале:

```bash
pytest test_app.py
```

### Что происходит в этом тесте?

- **Фикстура `temp_db`**: Создает временный файл базы данных для каждого теста. Это гарантирует, что каждый тест работает с чистой базой данных и не зависит от результатов других тестов.

- **Тест `test_create_user`**: Проверяет, что функция `create_user` корректно добавляет нового пользователя в базу данных. После добавления пользователя тест извлекает информацию о нем из базы данных и проверяет, что добавленные данные соответствуют ожидаемым.

### Где ещё используют фикстуры?

Фикстуры в Pytest могут использоваться для широкого спектра задач, не ограничиваясь только базами данных и файловыми операциями. Вот несколько других распространенных примеров использования фикстур:

### 1. Настройка сетевого соединения:

Фикстуры могут использоваться для установки сетевых соединений или моковых API-запросов для тестирования взаимодействия с внешними сервисами.

**Пример:**

```python
import pytest
import requests

@pytest.fixture
def mock_api_response(monkeypatch):
    def mock_get(*args, **kwargs):
        return {"data": "mocked data"}
    
    monkeypatch.setattr(requests, "get", mock_get)

def test_api_call(mock_api_response):
    response = requests.get("https://fakeapi.com/data")
    assert response["data"] == "mocked data"
```

### 2. Конфигурация приложения:

Фикстуры могут использоваться для настройки и изменения конфигурации приложения перед выполнением тестов, например, для установки тестовых параметров или переменных среды.

**Пример:**

```python
import pytest
import os

@pytest.fixture
def setup_environment():
    os.environ["TEST_ENV"] = "test"
    yield
    del os.environ["TEST_ENV"]

def test_configuration(setup_environment):
    assert os.getenv("TEST_ENV") == "test"
```

### 3. Инициализация и очистка объектов:

Фикстуры могут использоваться для создания сложных объектов, которые используются в тестах, и их очистки после тестирования.

**Пример:**

```python
import pytest

class ComplexObject:
    def __init__(self):
        self.state = 0
    def perform_operation(self):
        self.state += 1

@pytest.fixture
def complex_object():
    obj = ComplexObject()
    yield obj
    # Очистка или переустановка объекта
    obj.state = 0

def test_complex_operation(complex_object):
    complex_object.perform_operation()
    assert complex_object.state == 1
```

### 4. Имитация времени и даты:

Фикстуры могут использоваться для имитации определенного времени или даты в тестах, где важно контролировать временные рамки.

**Пример:**

```python
import pytest
from datetime import datetime
from freezegun import freeze_time

@pytest.fixture
def freeze_date():
    with freeze_time("2023-01-01"):
        yield

def test_date(freeze_date):
    assert datetime.now() == datetime(2023, 1, 1)
```

### 5. Фикстуры и датаклассы

```python
from dataclasses import dataclass
import pytest

@dataclass
class User:
    name: str
    age: int

@pytest.fixture
def user():
    return User(name="John Doe", age=30)

def test_user_age(user):
    assert user.age == 30

```
### Заключение:

Фикстуры в Pytest предоставляют гибкий и мощный способ настроить окружение для тестов, имитировать сложные взаимодействия и управлять состоянием приложения. Они могут использоваться для широкого спектра задач, помогая тебе писать более структурированные, надежные и повторяемые тесты для любых аспектов твоего приложения!

## 1.2. Параметризация тестов 🧪

Юный падаван, параметризация в Pytest — это мощный способ запуска одного и того же теста с различными входными данными. Это позволяет тебе проверять различные сценарии и краевые случаи без необходимости писать множество почти идентичных тестов.

### Основы параметризации:

**1. Что такое параметризация?**
Параметризация в тестировании — это подход, при котором ты определяешь набор входных данных (параметров) и ожидаемых результатов. Затем тестовый фреймворк автоматически запускает тест несколько раз, каждый раз с разными значениями параметров.

**2. Преимущества параметризации:**
- **Сокращение дублирования кода**: Ты пишешь логику теста один раз, а затем просто передаешь разные параметры.
- **Повышение покрытия тестами**: Легко добавлять новые тестовые случаи, просто указывая дополнительные наборы параметров.
- **Улучшение читаемости и поддержки**: Тесты становятся более структурированными и легче читаемыми, так как отделяют тестовые данные от логики теста.

### Как работает параметризация в Pytest:

**1. Определение параметров:**
Ты определяешь параметры для теста, чаще всего в виде списка или кортежей, где каждый элемент списка или кортежа представляет различные значения для одного запуска теста.

**2. Автоматический запуск тестов:**
Pytest автоматически запускает тест столько раз, сколько есть наборов параметров, каждый раз передавая следующий набор значений в тестовую функцию.

**3. Анализ результатов:**
Результаты каждого запуска теста с разными параметрами отображаются отдельно, что позволяет легко определить, какие конкретные наборы данных приводят к ошибкам или неожиданному поведению.

### Практическое применение параметризации:

**1. Тестирование функций с различными входными данными:**
Если у тебя есть функция, которая должна работать с различными значениями, ты можешь использовать параметризацию для проверки ее поведения с разными входами.

**2. Краевые случаи и условия ошибок:**
Ты можешь определить параметры для краевых случаев или условий, которые известно вызывают ошибки, чтобы убедиться, что твоя программа корректно обрабатывает эти ситуации.

**3. Тестирование на совместимость:**
Если твое приложение должно работать в различных средах или с разными версиями компонентов, ты можешь использовать параметризацию для тестирования его в каждой из этих сред.

Используется декоратор `@pytest.mark.parametrize`:

```python
import pytest

@pytest.mark.parametrize("input_value, expected_output", [
    (1, 2),
    (2, 3),
    (3, 4),
])
def test_increment(input_value, expected_output):
    assert input_value + 1 == expected_output
```

### Когда использовать параметризацию:

**А. Проверка функций с различными входными данными:**
Если функция должна обрабатывать различные входные данные, параметризация позволяет легко проверить её работу с разными значениями.

**Б. Краевые случаи:**
Для проверки того, как система реагирует на краевые случаи или необычные условия.

**В. Сценарии использования:**
Когда один и тот же процесс или функционал может исполняться в разных сценариях или с разными параметрами.

### Когда избегать параметризации:

**А. Простые тесты:**
Для очень простых тестов, где нет необходимости в различных входных данных, параметризация может быть излишней.

**Б. Уникальные тестовые сценарии:**
Если каждый тест требует уникальной настройки или очень специфичной логики, параметризация может усложнить код и сделать его менее читаемым.

**В. Очень сложные зависимости:**
Если тесты имеют сложные зависимости или требуют очень специфичной настройки окружения, параметризация может стать скорее обузой.

### Хранение данных для параметризации:

**А. В самом тесте:**
Для простых случаев список параметров может быть определен прямо в декораторе `@pytest.mark.parametrize` в тестовом файле.

**Б. Внешние файлы:**
Для более сложных или объемных данных можно использовать внешние файлы, такие как JSON, YAML или CSV. Эти файлы можно считывать в тестовом коде и передавать в тесты.

**В. Фикстуры:**
Фикстуры могут использоваться для предоставления параметров тестам, особенно если данные для параметризации требуют предварительной обработки или инициализации.

### В каком виде хранятся данные:

**А. Простые списки или кортежи:**
Часто используются для представления параметров и ожидаемых результатов, особенно в декораторе `@pytest.mark.parametrize`.

**Б. Файлы формата JSON, YAML, CSV:**
Подходят для хранения сложных данных, списков или словарей, особенно когда эти данные используются во многих тестах.

**В. Генерируемые данные:**
В некоторых случаях данные для тестов могут генерироваться динамически с использованием кода или специальных библиотек.

### Заключение:

Параметризация — это мощный инструмент, который может значительно улучшить твои тесты, сделав их более гибкими и всесторонними. Однако важно использовать его осмысленно и в соответствующих случаях. Хранение данных для параметризации должно быть организовано таким образом, чтобы обеспечить легкость доступа и изменения, а также поддерживать читаемость и понятность тестов!


## Параметры `@pytest.mark.parametrize`

Давай подробно рассмотрим параметры декоратора `@pytest.mark.parametrize`, используемого для параметризации тестов в Pytest.

### 1. `argnames` (Обязательный)
- **Описание**: Строка (для одного аргумента) или список/кортеж строк (для нескольких аргументов), указывающих имена аргументов, которые будут переданы в тестовую функцию.
- **Роль**: Определяет переменные, которые будут параметризованы в тесте.

### 2. `argvalues` (Обязательный)
- **Описание**: Список или итерируемый объект, каждый элемент которого представляет собой набор значений для аргументов, указанных в `argnames`.
- **Роль**: Предоставляет конкретные данные, которые будут протестированы в каждом вызове тестовой функции.

### 3. `indirect` (Необязательный)
- **Описание**: Булево значение или список/кортеж булевых значений соответствующих `argnames`. Указывает, должны ли аргументы обрабатываться как имена фикстур.
- **Роль**: При `indirect=True` Pytest будет считать значение аргумента именем фикстуры и вызовет эту фикстуру для получения реального значения. Это полезно для динамического создания тестовых данных или когда необходимо использовать фикстуру для инициализации параметра.

### 4. `ids` (Необязательный)
- **Описание**: Список строк, который должен содержать уникальный идентификатор для каждого набора параметров, или функция, которая принимает один набор параметров и возвращает идентификатор.
- **Роль**: Позволяет лучше идентифицировать каждый тестовый случай при просмотре результатов. Если `ids` не предоставлен, Pytest автоматически сгенерирует идентификаторы.

### 5. `scope` (Необязательный)
- **Описание**: Один из `function`, `class`, `module`, `package`, или `session`. Этот параметр доступен только если `indirect=True` и указывает, как часто вызывается фикстура для данного параметра.
- **Роль**: Определяет область, в которой параметризованная фикстура будет пересоздаваться. Например, при `scope='module'` фикстура будет вызвана один раз на модуль.

### Как и когда использовать эти параметры:
- **Прямая параметризация**: Когда ты хочешь проверить функцию с различными входными значениями, используй `argnames` и `argvalues` для прямой передачи значений.
- **Индиректная параметризация**: Когда тебе нужно провести более сложную настройку или инициализацию данных (например, подключение к базе данных), используй `indirect=True` для вызова фикстур.
- **Кастомные идентификаторы**: Если ты хочешь, чтобы отчеты о тестах были более информативными и понятными, используй `ids` для определения уникальных идентификаторов для каждого набора параметров.

Использование этих параметров позволяет создавать тесты, адаптированные к различным условиям и требованиям, улучшая покрытие и обеспечивая более высокое качество тестирования.

## Примеры параметризации

Давай создадим пять примеров параметризации тестов с использованием Pytest, постепенно увеличивая сложность. Начнем с простого примера и постепенно перейдем к более сложным сценариям, включая использование фикстур и тестирование классов.

### Пример 1: Простая параметризация

Простой тест для проверки функции сложения:

```python
import pytest

def add(a: int, b: int) -> int:
    return a + b

@pytest.mark.parametrize("a, b, expected", [(1, 2, 3), (4, 5, 9), (-1, 1, 0)])
def test_add(a: int, b: int, expected: int):
    assert add(a, b) == expected, f"Сложение {a} и {b} должно быть {expected}"
```

### Пример 2: Параметризация с использованием фикстуры

Тестирование функции, которая преобразует список в строку:

```python
import pytest

def list_to_string(lst: list) -> str:
    return ','.join(map(str, lst))

@pytest.fixture
def sample_list() -> list:
    return [1, 2, 3]

@pytest.mark.parametrize("expected", ["1,2,3"])
def test_list_to_string(sample_list: list, expected: str):
    assert list_to_string(sample_list) == expected, f"Преобразование {sample_list} должно быть {expected}"
```

### Пример 3: Сложная параметризация с множественными параметрами

Тестирование функции, которая проверяет, является ли строка палиндромом:

```python
import pytest

def is_palindrome(s: str) -> bool:
    return s == s[::-1]

@pytest.mark.parametrize("s, expected", [("radar", True), ("hello", False), ("", True)])
def test_is_palindrome(s: str, expected: bool):
    assert is_palindrome(s) is expected, f"Строка {s} {'является' if expected else 'не является'} палиндромом"
```

### Пример 4: Параметризация с созданием сложных объектов

Тестирование функции, которая работает со словарем:

```python
import pytest

def get_value(data: dict, key: str) -> int:
    return data.get(key, -1)

@pytest.mark.parametrize("data, key, expected", [({"a": 1, "b": 2}, "b", 2), ({"x": 10}, "y", -1)])
def test_get_value(data: dict, key: str, expected: int):
    assert get_value(data, key) == expected, f"Значение по ключу {key} должно быть {expected}"
```

### Пример 5: Параметризация в классе тестов

Тестирование методов класса:

```python
import pytest

class Calculator:
    def multiply(self, a: int, b: int) -> int:
        return a * b

    def subtract(self, a: int, b: int) -> int:
        return a - b

@pytest.mark.parametrize("method, a, b, expected", [("multiply", 2, 3, 6), ("subtract", 10, 5, 5)])
def test_calculator(method: str, a: int, b: int, expected: int):
    calculator = Calculator()
    result = getattr(calculator, method)(a, b)
    assert result == expected, f"{method}({a}, {b}) должно быть {expected}"
```

В последнем примере мы используем класс `Calculator` с методами `multiply` и `subtract`. Тест параметризован для обоих методов, проверяя их с разными входными данными.

Эти примеры демонстрируют различные способы использования параметризации в Pytest, начиная от простых функций и заканчивая более сложными сценариями с использованием фикстур и классов!

### Пример 3 и 5 с подгрузкой данных

Чтобы подключить данные из внешнего источника для параметризации в Pytest, ты можешь использовать внешние файлы, такие как JSON или CSV. Давай модифицируем 3-й и 5-й примеры так, чтобы они получали данные из внешнего файла.

### Пример 3: Сложная параметризация с внешними данными (JSON)

Допустим, у тебя есть файл `palindrome_cases.json` с тестовыми случаями:

```json
[
    {"s": "radar", "expected": true},
    {"s": "hello", "expected": false},
    {"s": "", "expected": true}
]
```

Теперь давай напишем тест:

```python
import pytest
import json

def is_palindrome(s: str) -> bool:
    return s == s[::-1]

# Функция для загрузки данных из JSON файла
def load_test_cases(filename: str):
    with open(filename, 'r') as file:
        return json.load(file)

@pytest.mark.parametrize("test_case", load_test_cases("palindrome_cases.json"))
def test_is_palindrome(test_case):
    s, expected = test_case["s"], test_case["expected"]
    assert is_palindrome(s) is expected, f"Строка {s} {'является' if expected else 'не является'} палиндромом"
```

### Пример 5: Параметризация в классе тестов с внешними данными (CSV)

Допустим, у тебя есть файл `calculator_cases.csv` с тестовыми случаями:

```csv
method,a,b,expected
multiply,2,3,6
subtract,10,5,5
```

Теперь давай напишем тест:

```python
import pytest
import csv

class Calculator:
    def multiply(self, a: int, b: int) -> int:
        return a * b

    def subtract(self, a: int, b: int) -> int:
        return a - b

# Функция для загрузки данных из CSV файла
def load_test_cases(filename: str):
    with open(filename, newline='') as csvfile:
        return list(csv.DictReader(csvfile))

@pytest.mark.parametrize("test_case", load_test_cases("calculator_cases.csv"))
def test_calculator(test_case):
    calculator = Calculator()
    method, a, b, expected = test_case["method"], int(test_case["a"]), int(test_case["b"]), int(test_case["expected"])
    result = getattr(calculator, method)(a, b)
    assert result == expected, f"{method}({a}, {b}) должно быть {expected}"
```

В этих примерах данные для параметризации загружаются из внешних файлов. Это делает тесты более универсальными и позволяет легко добавлять или изменять тестовые случаи без необходимости вносить изменения непосредственно в код тестов.
## Параметризация + фикстуры

Pytest параметризация и фикстуры часто используются вместе для создания более мощных и гибких тестовых сценариев. Эта комбинация позволяет тестам быть более модульными и адаптивными, предоставляя широкие возможности для тестирования различных условий и конфигураций. 

### Как работает комбинация фикстур и параметризации:

**1. Фикстуры для установки окружения:**
Фикстуры используются для настройки тестового окружения или состояния перед выполнением теста. Они могут предоставлять объекты, конфигурации, соединения с базами данных и другие необходимые ресурсы.

**2. Параметризация для вариативности данных:**
Параметризация позволяет запускать один и тот же тест с разными входными данными. Это особенно полезно для проверки функций и методов, которые должны корректно работать с разнообразными данными или в различных условиях.

### Применение в комбинации:

**1. Различные сценарии с одним набором данных:**
Ты можешь использовать фикстуру для создания определенного тестового состояния и затем применять параметризацию для выполнения теста с различными вариантами одного и того же набора данных. Это полезно для проверки того, как система реагирует на разные сценарии при одних и тех же входных данных.

**2. Один сценарий с различными данными:**
Наоборот, можно использовать параметризацию для тестирования различных наборов данных в одном и том же тестовом окружении, созданном с помощью фикстур. Это часто применяется для проверки функций обработки данных или валидации.

**3. Комплексное тестирование с разными условиями и данными:**
Для более комплексных сценариев ты можешь комбинировать несколько фикстур и параметров в одном тесте, чтобы проверить, как различные элементы системы работают вместе при различных условиях и входных данных.

### Преимущества комбинации:

- **Гибкость**: Комбинирование позволяет создавать тесты, которые могут легко адаптироваться и проверять различные сценарии и условия.
- **Эффективность**: Использование параметризации с фикстурами сокращает дублирование кода и позволяет легко расширять тесты для проверки новых случаев.
- **Лучшее покрытие тестами**: Эта комбинация обеспечивает более тщательное тестирование, позволяя проверять множество вариантов и конфигураций.


## Пример кода комбинации фикстуры и параметризации

Ты можешь скомбинировать загрузку данных из внешних источников с использованием фикстур и параметризации в Pytest. Это делает тесты еще более гибкими и мощными. Давай модифицируем примеры 3 и 5, используя фикстуры для загрузки данных и параметризацию для их применения в тестах.

### Пример 3: Сложная параметризация с внешними данными (JSON) и фикстурой

```python
import pytest
import json

def is_palindrome(word) -> bool:
    return word.lower().replace(' ', '') == word[::-1].lower().replace(' ', '')

@pytest.fixture
def json_data(request):
    json_str = """[
    ["дуд", true],
    ["дудка", false],
    ["банан", false],
    ["bob", true],
    ["bobik", false],
    ["бобер", false]
    ]"""
    data = json.loads(json_str)
    word, result = data[request.param]
    return word, result

# В parametrize передаем индексы для фикстуры, indirect=True указывает, что данные берутся через фикстуру
@pytest.mark.parametrize('json_data', range(6), indirect=True)
def test_is_palindrome_param(json_data):
    word, result = json_data
    assert is_palindrome(word) == result, f'Слово "{word}" не является палиндромом'

```
Конечно, давайте разберем второй пример подробно, чтобы вы могли лучше понять, как он работает с использованием фикстур и параметризации в `pytest`.

### Концепция

В этом примере мы создаем фикстуру, которая загружает данные из строки в формате JSON, и используем эти данные для параметризации наших тестов. Фикстура использует `request.param`, чтобы выбрать нужный элемент данных для каждого вызова теста, и `indirect=True` позволяет фикстуре получать входные данные для теста через параметры, указанные в `@pytest.mark.parametrize`.

### Импорты и функция проверки на палиндром

```python
import pytest
import json

def is_palindrome(word) -> bool:
    # Обработка слова: приводим к нижнему регистру и удаляем пробелы
    return word.lower().replace(' ', '') == word[::-1].lower().replace(' ', '')
```

### Определение фикстуры

```python
@pytest.fixture
def json_data(request):
    # Строка, содержащая данные в формате JSON
    json_str = """[
    ["дуд", true],
    ["дудка", false],
    ["банан", false],
    ["bob", true],
    ["bobik", false],
    ["бобер", false]
    ]"""
    # Загружаем данные из строки JSON в Python список
    data = json.loads(json_str)
    # Используем request.param для получения индекса текущего теста
    word, result = data[request.param]
    return word, result
```

### Параметризация и использование фикстуры

```python
# В parametrize передаем индексы для фикстуры, indirect=True указывает, что данные берутся через фикстуру
@pytest.mark.parametrize('json_data', range(6), indirect=True)
def test_is_palindrome_param(json_data):
    word, result = json_data
    assert is_palindrome(word) == result, f'Слово "{word}" не является палиндромом'
```

#### Подробное объяснение:

1. **`@pytest.fixture`**: Эта декорация определяет фикстуру. Фикстура — это функция, которая запускается перед каждым тестом, в котором она используется. Фикстура `json_data` загружает данные из строки JSON и возвращает пару значений (слово и ожидаемый результат) на основе `request.param`.

2. **`request.param`**: Это специальный параметр, который предоставляется `pytest` для доступа к параметрам теста в фикстуре. Он используется для того, чтобы выбрать нужный элемент из списка данных. Каждый раз при выполнении теста, `pytest` изменяет значение `request.param` в соответствии с заданным в `parametrize`.

3. **`@pytest.mark.parametrize`**:
   - `'json_data'`: имя параметра теста.
   - `range(6)`: создает последовательность индексов от 0 до 5, что соответствует числу элементов в данных JSON.
   - `indirect=True`: указывает `pytest`, что значения в `range(6)` должны быть переданы не напрямую в тест, а через фикстуру `json_data`, которая использует эти значения для выбора нужных данных.

4. **Тестовая функция `test_is_palindrome_param`**: принимает результаты из фикстуры `json_data` (слово и результат) и проверяет, является ли слово палиндромом. Сообщение об ошибке указывает, что слово должно быть палиндромом, если тест не проходит.

Этот подход позволяет контролировать, какие данные передаются в каждый тест, делая тесты более гибкими и мощными за счет использования фикстур и параметризации в `pytest`.

### Пример 5: Параметризация в классе тестов с внешними данными (CSV) и фикстурой

```python
import pytest
import csv

class Calculator:
    def multiply(self, a: int, b: int) -> int:
        return a * b

    def subtract(self, a: int, b: int) -> int:
        return a - b

# Фикстура для загрузки данных из CSV файла
@pytest.fixture(scope="module")
def calculator_test_cases():
    with open("calculator_cases.csv", newline='') as csvfile:
        return list(csv.DictReader(csvfile))

@pytest.mark.parametrize("test_case", calculator_test_cases())
def test_calculator(test_case):
    calculator = Calculator()
    method, a, b, expected = test_case["method"], int(test_case["a"]), int(test_case["b"]), int(test_case["expected"])
    result = getattr(calculator, method)(a, b)
    assert result == expected, f"{method}({a}, {b}) должно быть {expected}"
```

В этом примере, фикстура `calculator_test_cases` загружает тестовые случаи из файла CSV, и параметризация использует эти данные для запуска теста `test_calculator`.

### Заключение:

Комбинирование загрузки данных с помощью фикстур и параметризации в Pytest позволяет создать очень мощные и гибкие тестовые сценарии. Фикстуры обеспечивают централизованное управление тестовыми данными, а параметризация позволяет легко применять эти данные к различным тестам. Это уменьшает дублирование кода и делает тесты более читаемыми и легко расширяемыми, мой юный падаван!
### Заключение:

Использование параметризации и фикстур в комбинации — это мощный способ увеличить область покрытия тестами и обеспечить более глубокое и всестороннее тестирование. Это позволяет тестам быть более модульными, адаптивными и легко расширяемыми для учета новых требований и условий!


## Параметры декоратора фикстуры

Декоратор фикстуры в Pytest позволяет управлять поведением фикстур с помощью различных параметров. Вот несколько наиболее популярных параметров, которые часто используются для настройки фикстур, от самых популярных к менее распространенным:

### 1. `scope`
- **Описание**: Определяет, как часто фикстура должна вызываться: один раз для всех тестов, для каждого теста, и так далее.
- **Значения**:
  - `function`: Фикстура вызывается для каждого теста (по умолчанию).
  - `class`: Фикстура вызывается один раз для всех тестов в классе.
  - `module`: Фикстура вызывается один раз для всех тестов в модуле.
  - `session`: Фикстура вызывается один раз для всех тестов в сессии.

### 2. `autouse`
- **Описание**: Указывает, должна ли фикстура автоматически использоваться в тестах (без явного указания в параметрах тестов).
- **Значения**:
  - `True`: Фикстура автоматически применяется ко всем тестам в области видимости.
  - `False`: Фикстура используется только когда явно указана в параметрах теста (по умолчанию).

### 3. `params`
- **Описание**: Позволяет параметризировать фикстуры, передавая набор параметров, на основе которых фикстура будет выполняться с различными значениями.
- **Значения**: Список или кортеж значений, которые будут переданы в фикстуру.

### 4. `ids`
- **Описание**: Предоставляет пользовательские идентификаторы для каждого набора параметров. Используется вместе с параметром `params` для улучшения читаемости отчетов тестов.
- **Значения**: Список строковых идентификаторов, соответствующих каждому набору параметров.

### 5. `name`
- **Описание**: Позволяет назначить альтернативное имя фикстуре, которое будет использоваться вместо имени функции фикстуры.
- **Значения**: Строка, представляющая новое имя фикстуры.

Эти параметры позволяют тебе контролировать жизненный цикл и поведение фикстур, делая их более гибкими и мощными для различных тестовых сценариев. Используй их с умом, чтобы оптимизировать свои тесты и сделать их более эффективными и легко поддерживаемыми!


Параметр `scope` в фикстуре Pytest определяет уровень, на котором фикстура будет пересоздаваться и использоваться в тестах. Два значения этого параметра, `module` и `session`, отличаются по области действия и использованию:

### Scope `module`:
- **Описание**: Фикстура с областью действия `module` создается один раз для каждого тестового модуля. Если в модуле есть несколько тестов, все они будут использовать один и тот же экземпляр фикстуры.
- **Использование**: Используй `module`, когда хочешь, чтобы состояние фикстуры было общим для всех тестов в одном модуле. Это может быть полезно, например, при установке дорогостоящего соединения с базой данных, которое хочется установить один раз и использовать для всех тестов в модуле.

### Scope `session`:
- **Описание**: Фикстура с областью действия `session` создается один раз для всей тестовой сессии, независимо от того, сколько модулей или тестов запускается. Все тесты во всех модулях будут использовать один и тот же экземпляр фикстуры.
- **Использование**: Используй `session`, когда хочешь, чтобы фикстура была инициализирована один раз для всего набора тестов, например, при настройке внешнего ресурса или сервиса, который не изменяется в течение сессии и дорогостоящ в инициализации. Это также может быть полезно для оптимизации производительности, снижая время на установку и разрушение фикстуры.

### Использование параметра `autouse`:

**1. Что делает `autouse`**:
Параметр `autouse=True` заставляет фикстуру автоматически применяться ко всем тестам в ее области действия, без необходимости явно указывать ее в параметрах каждого теста.

**2. Когда использовать `autouse`**:
- **Общие зависимости**: Когда у тебя есть фикстура, необходимая практически для каждого теста, например, логирование, настройка общего окружения или мокирование внешних сервисов.
- **Неявные действия**: Для выполнения действий перед началом или после завершения тестов, таких как очистка или подготовка ресурсов, которые не требуют явного взаимодействия с тестами.
- **Упрощение кода**: Чтобы избежать повторения и упростить код тестов, особенно когда тесты разрастаются и становятся сложнее.


## 1.3. Маркеры 📍

Маркеры помогают выбирать, какие тесты нужно запустить. Существуют встроенные маркеры (например, `@pytest.mark.skip`), а также можно создать свои.

Для создания своего маркера просто добавьте его к функции теста:

```python
import pytest

@pytest.mark.slow_test
def test_slow_thing():
    assert True
```

Для запуска только медленных тестов используйте аргумент `-m`:

```
pytest -m slow_test
```

## 1.4. Конфигурация тестов ⚙️

Конфигурация тестов в pytest делается с помощью файла `pytest.ini`, `tox.ini` или `setup.cfg`, который содержит раздел `[pytest]`. Некоторые параметры могут быть переданы в командной строке или быть указаны в самом тестовом модуле.

Файл `pytest.ini` пример:

```
[pytest]
addopts = --durations=5
```

Данный файл установит значение, которое выводит пять самых медленных тестов при каждом запуске. 

## 1.5. Плагины 🎛

Pytest поддерживает разные плагины, которые расширяют возможности тестирования. Некоторые плагины входят в стандартный пакет, другие устанавливаются отдельно. Для установки плагина исполезуйте `pip`:

```
pip install pytest-cov
```

Затем его можно настроить и использовать в коде и командной строке.
## Введение в мокирование 🌱

Мокирование - это процесс замены настоящих объектов или функций **мок-объектами**, которые повторяют поведение реальных, но очень упрощенных. Использование мокирования помогает изолировать тестируемый код от зависимых компонентов, что гарантирует соответствие проверок условиям ваших тестов.

Мокирование полезно в следующих ситуациях:

- Ускорение тестов, заменой медленных функций или методов.
- Проверка, что определенные функции были вызваны с нужными аргументами и количеством раз.
- Имитация редких условий, типа ошибок или исключений.

📦 В Python для создания моков используются библиотеки, такие как `unittest.mock` из стандартной библиотеки и `py-mock`, которая основана на функциональности `unittest.mock`. В данной статье будем использовать `py-mock`, работая совместно pytest.

## Создание моков 🎨

Для начала инсталлируем `py-mock` и `pytest` с помощью pip, если это еще не сделано:

```shell
pip install pytest pymock
```

Рассмотрим пример функции, которую тестируем (*function.py*): 

```python
import requests

def get_data(url):
    response = requests.get(url)
    return response.json()
```

Для тестирования функции `get_data` нужно создать мок `requests.get()` с модулем `pymock`. В файл с тестами (*test_function.py*) добавим следующий код:

```python
from pytest_mock import create_autospec
import function
import requests

def test_get_data(mocker):
    mock_get = create_autospec(requests.get)
    url = 'https://example/api/data'
    expected_output = {'data': 'Test'}

    mock_get.return_value.json.return_value = expected_output
    mocker.patch.object(requests, 'get', mock_get)

    result = function.get_data(url)
    assert result == expected_output

    # Проверяем что мок вызывался с правильными аргументами
    mock_get.assert_called_once_with(url)
```

В этом примере использован метод `create_autospec()` чтобы создать мок для `requests.get`. Затем, методу `.return_value.json.return_value` присваивается ожидаемый результат, который мок должен возвращать вместо реального вызова. 

## Инспекция моков 🔍

Методы инспекции позволяют проверить моки уже после вызова. Воспользуемся методом инспекции `pytest_mock.create_autospec()` и проверим вызовы мока `requests.get`.

```python
from unittest import TestCase
from pytest_mock import create_autospec

class TestMyMocks(TestCase):
    def test_check_mocks_called(self, mocker):
        my_mock = create_autospec(MyClass)
        my_mock.my_method(12)
        my_mock.some_method()

        my_mock.assert_has_calls([
            mocker.call.my_method(12),
            mocker.call.some_method()
        ])
```

## Мокирование сложных объектов 😵

Бывает нужно создать мок сложнее, например описывающий классы с функциями и атрибутами, можно применить функцию `create_autospec()`. Предположим, мы хотим создать мок объект класса `UserManager`, имеющего функцию `create_user`.

```python
class UserManager:
    def create_user(self, username):
        if not username:
            return False
        # код создания пользователя
        return True

def test_create_user(mocker):
    mock_user_mgr = create_autospec(UserManager)

    mock_user_mgr.create_user.return_value = True
    assert mock_user_mgr.create_user("UserName") == True

    mock_user_mgr.create_user.return_value = False
    assert mock_user_mgr.create_user("") == False

    mock_user_mgr.create_user.assert_has_calls([
        mocker.call("UserName"),
        mocker.call("")
    ])
```

## Интеграция с Pytest ↔️

pytest_already_configured интергировался с жизненным циклом `pytest` также числом ( например запуском методов) что позволяет уводителю проверять ассерции перед перехотначением на следующий тест. замена кастомаизиан parametrize 

Благодаря тесной интеграции c pytest , `pytest_mock`, кстати без лисуств, делает эффективное, понимано тестирование напримере:

```python
import pytest
import my_class

def test_divide_operation(mocker):
    m = mocker.Mock()
    m.divide.return_value = 4
    divide_mock_call = mocker.patch('my_class.Engine.divide', m)
    engine = my_class.Engine()
    res =_engine.divide(12, 3)
    assert 23
```
## Моки Unittest

Мокирование в PyTest, и в Python в целом, часто используется для имитации работы объектов, которые в реальных условиях трудно настроить или они влияют на внешние системы. Моки помогают изолировать тестируемую систему от внешних зависимостей, позволяя тестировать функциональность в контролируемой среде.

### Инструменты для Мокирования

Основным инструментом для мокирования в Python является библиотека `unittest.mock`, входящая в стандартную библиотеку Python. Она предоставляет множество классов и функций для создания мок-объектов.

Основные компоненты `unittest.mock`:

1. **Mock**: Основной класс для создания мок-объектов. Позволяет имитировать поведение других объектов.
2. **MagicMock**: Расширение класса Mock, который имитирует магические методы Python (например, `__len__`, `__str__` и т.д.).
3. **patch**: Декоратор/контекстный менеджер для динамического замещения атрибутов во время выполнения тестов. Очень полезен для замещения модулей или классов в тестируемом коде.

### Примеры Синтаксиса

#### Использование Mock

```python
from unittest.mock import Mock

# Создание мок-объекта
mock_obj = Mock()

# Вызов метод
```
Понял ваш запрос, давайте обсудим мокирование в контексте PyTest с использованием `unittest.mock`.

### Основы Мокирования с unittest.mock в PyTest

Мокирование используется для замены реальных объектов в вашем коде специальными объектами (моками), которые имитируют их поведение. Это полезно, когда ваши тесты взаимодействуют с внешними системами или имеют сложные зависимости, которые сложно воссоздать в тестовой среде.

#### Создание Простого Мока

Используя `unittest.mock`, вы можете создать мок-объект для имитации интерфейса другого объекта:

```python
from unittest.mock import Mock

# Создание мока
mocked_function = Mock()

# Использование мока в тесте
mocked_function.return_value = 42  # Задаем возвращаемое значение
assert mocked_function() == 42  # Проверяем, что мок возвращает заданное значение
```

#### Мокирование с помощью Patch

`patch` — это удобный инструмент для замены реальных объектов в модулях моками:

```python
from unittest.mock import patch
import some_module

@patch('some_module.some_function')
def test_some_function(mocked_function):
    # Установка возвращаемого значения мока
    mocked_function.return_value = 'mocked value'

    # Вызов функции, которая использует замокированную функцию
    result = some_module.function_calling_some_function()

    # Проверка, что мок был вызван и возвращает ожидаемое значение
    mocked_function.assert_called_once()
    assert result == 'mocked value'
```

В этом примере мы замокировали `some_function` из модуля `some_module`. Теперь при вызове `some_function` внутри `function_calling_some_function`, будет использоваться мок-объект.

#### Параметризация и Моки

PyTest позволяет комбинировать параметризацию и мокирование для создания более сложных тестовых сценариев:

```python
import pytest
from unittest.mock import Mock

@pytest.fixture
def mocked_function():
    return Mock()

@pytest.mark.parametrize("input,expected", [(10, True), (0, False)])
def test_with_mock_and_parameters(mocked_function, input, expected):
    mocked_function.return_value = expected
    assert some_module.some_function_using_mock(input) == expected
```

В этом примере используется фикстура, создающая мок-объект, и параметризация для проверки разных сценариев функции, использующей мок.

### Заключение

Мокирование в PyTest с `unittest.mock` — это мощный способ контролировать и тестировать поведение вашего кода в изолированной среде. Оно особенно полезно при работе с внешними API, базами данных или другими сложными системами.

Давайте рассмотрим пример, в котором у нас есть две функции: одна для чтения данных из JSON-файла и другая для выполнения поиска в этих данных. Мы будем мокировать функцию чтения JSON, чтобы протестировать функцию поиска в контексте интеграционного теста с использованием PyTest.

### Функции для Тестирования

Предположим, у нас есть следующие функции:

```python
import json

def read_json(file_name):
    """Читает JSON файл и возвращает данные."""
    with open(file_name, 'r') as file:
        return json.load(file)

def find_item(file_name, key, value):
    """Ищет элемент в JSON по заданному ключу и значению."""
    data = read_json(file_name)
    return next((item for item in data if item.get(key) == value), None)
```

Здесь `read_json` читает данные из JSON-файла, а `find_item` использует `read_json` для поиска элемента с определенным ключом и значением.

### Интеграционный Тест с Мокированием

Теперь напишем тест, в котором мы будем мокировать `read_json` для проверки функциональности `find_item`.

```python
import pytest
from unittest.mock import patch
from your_module import find_item  # Импортируйте find_item из вашего модуля

@pytest.fixture
def mock_json_data():
    return [
        {"id": 1, "name": "Item1"},
        {"id": 2, "name": "Item2"}
    ]

@patch('your_module.read_json')
def test_find_item(mock_read_json, mock_json_data):
    # Настройка мока
    mock_read_json.return_value = mock_json_data

    # Тестирование функции find_item
    result = find_item("dummy_file.json", "name", "Item1")
    assert result == {"id": 1, "name": "Item1"}

    # Проверка, что мок был вызван
    mock_read_json.assert_called_with("dummy_file.json")
```

В этом тесте:

- Мы используем `patch` для мокирования функции `read_json`. Это означает, что при вызове `read_json` внутри `find_item` будет использоваться мок-объект.
- Фикстура `mock_json_data` предоставляет тестовые данные для мока.
- В тесте `test_find_item` мы проверяем, что `find_item` корректно находит элемент в мокированных данных.

Этот подход позволяет нам тестировать `find_item` без зависимости от реального чтения файлов, что делает тесты более стабильными и быстрыми.

Ваш пример демонстрирует использование мокирования для тестирования функциональности в Python с помощью библиотеки PyTest и `unittest.mock`. Давайте подробно разберем, как это работает.

### Функции для Тестирования

У вас есть две функции: `read_json` и `find_item`. Функция `read_json` читает данные из JSON-файла, а `find_item` использует `read_json` для поиска элемента в этих данных по заданному ключу и значению.

### Применение Мокирования

Вы хотите тестировать функцию `find_item`, но не хотите зависеть от реального файла JSON. Для этого вы используете мокирование - создаете поддельную версию функции `read_json`, которая возвращает заранее заданные данные, вместо чтения файла.

### Элементы Теста

1. **Импорт необходимых модулей**:
   - `pytest` для написания теста и создания фикстуры.
   - `patch` из `unittest.mock` для мокирования.
   - Импорт тестируемой функции `find_item` из вашего модуля.

2. **Создание Фикстуры `mock_json_data`**:
   - Эта фикстура возвращает список словарей, который имитирует данные, которые могли бы быть прочитаны из JSON-файла.

3. **Мокирование с помощью `patch`**:
   - `@patch('your_module.read_json')` - декоратор `patch` используется для замены реальной функции `read_json` в `your_module` моком.
   - `mock_read_json` в аргументах теста - это ссылка на мок-объект, созданный `patch`.

4. **Настройка Мока**:
   - `mock_read_json.return_value = mock_json_data` - это указывает моку возвращать данные из фикстуры `mock_json_data`, когда он вызывается.

5. **Тестирование Функции `find_item`**:
   - Вызывается `find_item` с тестовыми параметрами. Функция `read_json` внутри `find_item` заменена моком, так что `find_item` использует данные из `mock_json_data`.
   - `assert` используется для проверки, что результат выполнения `find_item` соответствует ожиданиям.

6. **Проверка Вызова Мока**:
   - `mock_read_json.assert_called_with("dummy_file.json")` - убеждаемся, что мокированная функция была вызвана с ожидаемым аргументом.

### Преимущества Этого Подхода

- **Изоляция от Внешних Зависимостей**: Тест `find_item` не зависит от наличия реального файла JSON и его содержимого.
- **Контроль Над Тестовыми Данными**: Вы точно знаете, с какими данными работает тест, что повышает его надежность.
- **Упрощение Тестирования**: Мокирование упрощает тестирование, позволяя сосредоточиться на логике функции `find_item`, а не на механизме чтения файлов.

### Еще пример с моком

```python

import json  
import pytest  
from unittest.mock import Mock  
  
  
class JSONReader:  
    def read_json(self, json_file_path):  
        with open(self.json_file_path, 'r') as json_file:  
            return json.load(json_file)  
  
  
class ItemSearcher:  
    def __init__(self, json_reader: JSONReader):  
        self.json_reader = json_reader  
  
    def find_item(self, file_name, key, value):  
        data = self.json_reader.read_json(file_name)  
        return [item for item in data if item[key] == value]  
  
  
# Фикстура мокирования чтения json файла  
@pytest.fixture(scope='module')  
def mock_json_reader():  
    mock_reader = Mock(spec=JSONReader)  # spec - ограничивает поведение мока  
    mock_reader.read_json.return_value = [  
        {'name': 'Alice', 'age': 30},  
        {'name': 'Bob', 'age': 35},  
        {'name': 'Charlie', 'age': 40}  
    ]  
    return mock_reader  
  
  
# Фикстура ItemSearcher с использованием мокирования JSONReader  
@pytest.fixture(scope='module')  
def item_searcher(mock_json_reader):  
    return ItemSearcher(mock_json_reader)  
  
  
PARAMS = [  
    ('users.json', 'name', 'Alice', [{'name': 'Alice', 'age': 30}]),  
    ('users.json', 'age', 35, [{'name': 'Bob', 'age': 35}]),  
    ('users.json', 'age', 100, [])  
]  
  
  
# Параметризованный тест  
@pytest.mark.parametrize('file_name, key, value, expected', PARAMS)  
def test_item_searcher(item_searcher, file_name, key, value, expected):  
    assert item_searcher.find_item(file_name, key, value) == expected
```

Ваш код демонстрирует использование различных функций и декораторов PyTest для создания сложных тестовых сценариев. Давайте подробно рассмотрим каждый элемент этого кода.

### Классы `JSONReader` и `ItemSearcher`

1. **`JSONReader`**:
   - Этот класс содержит метод `read_json`, который читает данные из JSON-файла и возвращает их.

2. **`ItemSearcher`**:
   - Конструктор принимает экземпляр `JSONReader`.
   - Метод `find_item` ищет элементы в данных JSON, которые соответствуют определенному ключу и значению.

### Фикстуры PyTest

1. **Фикстура `mock_json_reader`**:
   - Это фикстура, создающая мок (подделку) объекта `JSONReader`.
   - Используется `Mock` с параметром `spec`, который ограничивает мок поведением `JSONReader`, позволяя моку имитировать только методы и атрибуты, существующие в `JSONReader`.
   - `mock_reader.read_json.return_value` устанавливает возвращаемое значение метода `read_json` мока.

2. **Фикстура `item_searcher`**:
   - Создает экземпляр `ItemSearcher`, используя мокированный `JSONReader`.

Обе фикстуры используют `scope='module'`, что означает, что они будут созданы один раз для всего тестового модуля и переиспользованы во всех тестах этого модуля.

### Параметризация Тестов

- Декоратор `@pytest.mark.parametrize` используется для параметризации теста `test_item_searcher`. Это позволяет запускать один и тот же тестовый метод с разными наборами входных данных и ожидаемых результатов.

### Тестовая Функция `test_item_searcher`

- Тест `test_item_searcher` принимает параметры из параметризации и фикстуры `item_searcher`.
- Внутри теста происходит вызов `item_searcher.find_item` с параметрами и сравнение результата с ожидаемым значением.

### Как Это Работает

Когда PyTest запускается, он ищет тестовые функции и классы, соответствующие определенным шаблонам. Для каждого теста PyTest определяет, какие фикстуры ему нужны, и вызывает эти фикстуры. В вашем случае:

1. Перед запуском `test_item_searcher`, PyTest инициализирует фикстуры `mock_json_reader` и `item_searcher`.
2. Тест `test_item_searcher` выполняется несколько раз с разными значениями параметров, предоставляемыми через `@pytest.mark.parametrize`.
3. В каждом выполнении теста `find_item` использует мокированный `JSONReader`, который возвращает предопределенные тестовые данные.

Этот подход позволяет тестировать логику `ItemSearcher` без необходимости чтения реальных файлов и дает контроль над тестовыми данными, что повышает надежность и воспроизводимость тестов.


### Чем отличаются примеры с моками?

Отличие между двумя представленными примерами заключается в подходе к мокированию и том, как мок интегрирован в тесты.

### Пример 1: Использование `@patch`

В первом примере используется декоратор `@patch` из модуля `unittest.mock`. Этот декоратор динамически заменяет указанную цель (в данном случае `your_module.read_json`) на мок-объект на время выполнения теста.

- `@patch('your_module.read_json')` создает мок для функции `read_json` из модуля `your_module`. Этот мок передается в тестовую функцию как аргумент `mock_read_json`.
- Мок настраивается так, чтобы его метод `read_json` возвращал заранее определенные данные (`mock_json_data`).
- Это позволяет тестировать `find_item` без зависимости от реальной функции чтения данных, что делает тест более независимым и надежным.

### Пример 2: Использование Фикстур

Во втором примере мокирование выполняется с использованием фикстуры PyTest. Вместо `@patch`, мок создается внутри фикстуры, и затем этот мок передается в тесты через аргументы тестовых функций.

- Фикстура `mock_json_reader` создает и настраивает мок для `JSONReader`. Этот мок возвращается фикстурой.
- Фикстура `item_searcher` использует `mock_json_reader` для создания экземпляра `ItemSearcher` с мокированным `JSONReader`.
- В тесте `test_item_searcher`, `item_searcher` используется для выполнения тестов с мокированными данными.

### Почему Нет `@patch` во Втором Примере

- Во втором примере не используется `@patch`, потому что мокирование выполняется напрямую через фикстуры PyTest. Фикстура `mock_json_reader` заменяет необходимость в декораторе `@patch`, предоставляя мокированный объект непосредственно.
- Этот подход предоставляет большую гибкость и контроль над процессом мокирования, так как вы можете тонко настроить поведение мока и его взаимодействие с другими фикстурами.

### Заключение

Оба подхода валидны и выбор между ними зависит от конкретных требований к тестированию. `@patch` удобен для быстрого мокирования отдельных функций или методов, в то время как фикстуры предлагают большую гибкость и интеграцию с системой PyTest.

## 1. Тестирование классов и методов с Pytest 🐍

## 1.1. Структура класса для тестирования 📚

Для начала нужно создать простой класс, который мы будем тестировать. В этом примере создадим класс `Calculator` с несколькими арифметическими методами:

```python
class Calculator:
    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

    def multiply(self, a, b):
        return a * b

    def divide(self, a, b):
        if b == 0:
            raise ValueError("Делитель не может быть равен нулю")
        return a / b
```

Теперь создадим файл с тестами, например, `test_calculator.py`. Используя `pytest`, можно создавать отдельные тестовые функции или обернуть их в классы с префиксом `Test`. Внутри класса `TestCalculator` разместим методы с названиями, начинающимися на `test_`, чтобы `pytest` их автоматически определил как тесты:

```python
import pytest
from calculator import Calculator

class TestCalculator:
    def test_add(self):
        calc = Calculator()
        assert calc.add(2, 3) == 5
        
    def test_subtract(self):
        calc = Calculator()
        assert calc.subtract(5, 2) == 3

    def test_multiply(self):
        calc = Calculator()
        assert calc.multiply(2, 3) == 6

    # и так далее для всех методов
```

## 1.2. Тестирование конструкторов и инициализации 🏗️
   
В данном примере класс `Calculator` не имеет конструктора, но часто возникает необходимость протестировать варианты создания и инициализации объекта. К примеру, добавим в `Calculator` возможность хранения результата предыдущей операции:

```python
class Calculator:
    def __init__(self, initial_value=0):
        self.previous_result = initial_value

    # другие методы...

    def get_previous_result(self):
        return self.previous_result
```

Для тестирования инициализации добавим соответствующие тесты:

```python
class TestCalculator:
    # другие тесты...

    def test_initialization_without_initial_value(self):
        calc = Calculator()
        assert calc.get_previous_result() == 0

    def test_initialization_with_initial_value(self):
        calc = Calculator(5)
        assert calc.get_previous_result() == 5
```

## 1.3. Тестирование методов класса 💼

### Тестирование публичных методов 🌐

При тестировании публичных методов необходимо проверить положительные и негативные сценарии использования. В нашем примере для метода `add` положительным сценарием будет сумма двух чисел, а негативным сценарием может быть ввод строки вместо числа:

```python
class TestCalculator:
    # другие тесты...

    def test_add_with_numbers(self):
        calc = Calculator()
        assert calc.add(2, 3) == 5

    def test_add_with_string(self):
        calc = Calculator()
        with pytest.raises(TypeError):
            calc.add(2, "three")
```

### Тестирование приватных методов 🔒

Хотя утверждают, что приватные методы протестировать не обязательно, иногда это все же требуется. Преобразование имени приватного метода достаточно простое: к примеру, метод `_calculate` тестируется как `obj._<CLASSNAME>__calculate()`, где `CLASSNAME` – имя соответствующего класса.

## 1.4. Мокирование внутренних вызовов 🎭
    
В Pytest для мокирования обычно используют плагин `pytest-mock`, который предоставляет удобный доступ к возможностям мокирования из библиотеки `unittest.mock` и добавляет несколько дополнительных удобств. Вот как можно использовать `pytest-mock` для мокирования внутренних вызовов:

### 1. Установка и использование pytest-mock:
- **Установка**: Установите плагин `pytest-mock` через pip, если он еще не установлен.
- **Использование**: Плагин `pytest-mock` добавляет фикстуру `mocker`, которую можно использовать в тестах для создания и управления моками.

### 2. Мокирование внутренних вызовов:
- **Выбор цели**: Определите функцию или метод, который вы хотите замокировать. Это может быть метод объекта, функция в другом модуле и т.д.
- **Использование `mocker`**: Внутри теста, используйте фикстуру `mocker` для создания мока цели. Вы можете использовать методы `mocker.patch()`, `mocker.patch.object()` и другие для замены реальных объектов моками.
- **Настройка мока**: Настройте возвращаемые значения мока, побочные эффекты или утверждения о том, как и сколько раз он должен быть вызван.

### 3. Проверка результатов:
- **Проверка вызовов**: После выполнения теста используйте возможности мока для проверки, что он был вызван ожидаемым образом (с правильными аргументами, определенное количество раз и т.д.).
- **Проверка взаимодействия**: Убедитесь, что тестируемый код корректно взаимодействовал с мокированной функцией или методом и правильно обработал его возвращаемые значения или побочные эффекты.

Использование `pytest-mock` делает процесс мокирования в Pytest более простым и интуитивно понятным, обеспечивая интеграцию с мощными возможностями `unittest.mock` и улучшенный контроль над процессом тестирования.

Вот пример кода, который демонстрирует, как можно использовать `pytest-mock` для мокирования внутренних вызовов:

### Шаг 1: Установка `pytest-mock`
Убедитесь, что у вас установлен плагин `pytest-mock`. Если нет, установите его, используя pip:

```bash
pip install pytest-mock
```

### Шаг 2: Пример кода с мокированием

Допустим, у вас есть следующий модуль `calculator.py`, содержащий класс `Calculator` и внутренний вызов `complex_operation`:

```python
# calculator.py
class Calculator:
    def add(self, a, b):
        return a + b

    def calculate(self, x, y):
        result = self.add(x, y)
        return self.complex_operation(result)

    def complex_operation(self, value):
        # Представим, что это сложная операция
        return value * 2
```

Вы хотите протестировать метод `calculate`, мокируя внутренний вызов `complex_operation`. Вот как это можно сделать с использованием `pytest-mock`:

```python
# test_calculator.py
import pytest
from calculator import Calculator

def test_calculate_with_mocking(mocker):
    # Создаём экземпляр калькулятора
    calc = Calculator()

    # Мокируем метод complex_operation класса Calculator
    mock_complex_operation = mocker.patch.object(calc, 'complex_operation', return_value=10)

    # Вызываем метод calculate
    result = calc.calculate(2, 3)

    # Проверяем, что mock_complex_operation был вызван с правильным аргументом
    mock_complex_operation.assert_called_once_with(5)

    # Проверяем, что результат calculate соответствует ожидаемому значению
    assert result == 10, "Результат calculate должен соответствовать мокированному значению"
```

### Объяснение кода:
- **Установка мока**: Мы используем `mocker.patch.object` для создания мока метода `complex_operation`. Мы указываем, что при вызове этого метода он должен возвращать `10`.
- **Тестирование**: Вызываем метод `calculate`, который мы хотим протестировать. Он, в свою очередь, вызовет мокированную версию `complex_operation`.
- **Проверка**: Мы проверяем, что мок был вызван с правильным аргументом и что итоговый результат `calculate` соответствует ожидаемому значению мока.

Использование `pytest-mock` позволяет легко мокировать внутренние вызовы и контролировать поведение системы в тестах, делая их более предсказуемыми и надежными.
## 1.5. Тестирование исключений 🚧

Проверка выбрасывания исключений является важной частью тестирования, которая оценивает отказ методов в определенных ситуациях. Пример про тестирование метода `divide`:

```python
class TestCalculator:
    # другие тесты...

    def test_divide_with_zero_divisor(self):
        calc = Calculator()
        with pytest.raises(ValueError):
            calc.divide(2, 0)
```

Используя pytest, можно нотацией с `with` уверенно перехватывать исключения и сравнивать их сообщения, чтобы гарантировать корректную работу класса.



## 1. Продвинутые темы и лучшие практики Pytest 🚀

## 2. Параллельное выполнение тестов ⏩

Параллелизм может значительно ускорить выполнение набора тестов за счет распределения тестовых случаев между несколькими ядрами процессора. Для достижения этого в Pytest используется плагин `pytest-xdist`.

### 2.1. Установка плагина

```bash
pip install pytest-xdist
```

### 2.2. Запуск тестов в параллели

```bash
pytest -n NUM
```

где `NUM` - число ядер процессора, на которые вы хотите распределить тестовые случаи.


## ООП Тесты

В мире Pytest допустимо и иногда даже предпочтительно писать тесты в стиле ООП. ООП подход может улучшить структуру тестов, особенно когда их количество велико, или когда тесты разделяют общую логику и данные. Вот как это обычно работает:

### Писать ли тесты в ООП стиле?
- **Принято**: Да, использование классов для организации тестов принято в Pytest. Это может помочь группировать связанные тесты и обеспечить общие настройки для них с помощью фикстур.

### Группировка тестов в классы:
- **Логическая группировка**: Тесты, связанные с определенным функционалом или компонентом системы, могут быть сгруппированы в один класс. Например, все тесты для определенного модуля или API.
- **Общая установка/очистка**: Если несколько тестов должны использовать одни и те же настройки или ресурсы, их можно сгруппировать в класс, где общие фикстуры выполняют установку и очистку.
- **Иерархия тестов**: Ты можешь использовать наследование классов для создания иерархии тестов, где дочерние классы расширяют или модифицируют тесты родительских классов.

### Мокирование, фикстуры и параметризация в одном классе:
- **Мокирование**: Да, ты можешь использовать мокирование в классах тестов. Моки можно создавать как часть методов класса или с помощью фикстур на уровне класса.
- **Фикстуры**: Фикстуры могут быть как на уровне класса, так и на уровне метода. Фикстуры на уровне класса (`scope='class'`) будут запускаться один раз для всех тестов в классе.
- **Параметризация**: Да, ты можешь использовать параметризацию в методах класса. Однако, стоит отметить, что параметризация на уровне класса не поддерживается напрямую, но ты можешь параметризировать отдельные тестовые методы в классе.

### Пример использования:
В одном классе тестов ты можешь:
- Использовать фикстуры для общей настройки и очистки данных для группы тестов.
- Применять мокирование для имитации внешних зависимостей и проверки взаимодействия с ними.
- Параметризовать тестовые методы для выполнения с разными наборами данных.

```python
import os
from hw.hw_16 import TxtFileHandler
import pytest

class TestTxtFileHandler:
    @classmethod
    def setup_class(cls):
        """Создание экземпляра класса TxtFileHandler."""
        cls.txt_handler = TxtFileHandler('test.txt')

    @classmethod
    def teardown_class(cls):
        """Удаление файла после выполнения всех тестов."""
        try:
            os.remove('test.txt')
        except FileNotFoundError:
            pass

    def test_write_file(self):
        """Тестирование метода write_file с пустым списком."""
        self.txt_handler.write_file([])
        assert os.path.exists('test.txt')

    def test_append_file(self):
        """Тестирование метода append_file с добавлением данных."""
        self.txt_handler.append_file(['test'])
        with open('test.txt', 'r', encoding='utf-8') as file:
            assert file.read() == 'test'

```
В этом классе:

- Метод `setup_class` создает экземпляр `TxtFileHandler`, который будет использоваться во всех тестах класса.
- Метод `teardown_class` удаляет файл `test.txt` после выполнения всех тестов.
- Методы `test_write_file` и `test_append_file` выполняют соответствующие тесты.

Чтобы запустить этот тестовый класс с PyTest, убедитесь, что ваш файл теста называется в соответствии с соглашениями PyTest, например, `test_hw_16.py`, и запустите PyTest в той же директории, где находится тестовый файл.

Обратите внимание, что в этом примере мы используем методы `setup_class` и `teardown_class` для инициализации и очистки на уровне класса, а не на уровне отдельного теста. Это означает, что `TxtFileHandler` будет создан один раз для всех тестов в классе, и файл будет удален после завершения всех тестов в классе.

В тестовом классе, который использует методы `setup_class` и `teardown_class`, PyTest автоматически вызывает эти методы в определенные моменты времени во время выполнения тестов.

### Как Работает `setup_class`

Метод `setup_class` является классовым методом (означаемым декоратором `@classmethod`), который вызывается один раз перед выполнением первого теста в тестовом классе. В этом методе обычно выполняются действия по инициализации, которые необходимы для всех тестов в классе.

- В вашем случае, `setup_class` создает экземпляр класса `TxtFileHandler`. Этот экземпляр сохраняется как атрибут класса, что делает его доступным для всех тестовых методов в классе.

### Как Работает `teardown_class`

Метод `teardown_class` также является классовым методом и вызывается один раз после выполнения последнего теста в тестовом классе. В этом методе обычно выполняются действия по очистке, такие как закрытие соединений с базой данных, удаление созданных файлов и другие операции по восстановлению исходного состояния после тестирования.

- В вашем случае, `teardown_class` пытается удалить файл `test.txt`. Если файл не найден (например, он не был создан или уже удален), исключение `FileNotFoundError` перехватывается и игнорируется.

### Пример

```python
class TestTxtFileHandler:
    @classmethod
    def setup_class(cls):
        """Создание экземпляра класса TxtFileHandler."""
        cls.txt_handler = TxtFileHandler('test.txt')

    @classmethod
    def teardown_class(cls):
        """Удаление файла после выполнения всех тестов."""
        try:
            os.remove('test.txt')
        except FileNotFoundError:
            pass
```

- Когда PyTest запускает тесты в `TestTxtFileHandler`, он сначала вызывает `setup_class`, который инициализирует `cls.txt_handler`.
- Затем PyTest выполняет каждый тестовый метод в классе.
- После завершения всех тестов в классе PyTest вызывает `teardown_class`, который удаляет файл `test.txt`.

Этот подход обеспечивает, что все тесты в классе используют один и тот же экземпляр `TxtFileHandler` и что файл очищается после завершения всех тестов, вне зависимости от того, успешно они завершились или нет.

В PyTest есть несколько основных хуков, которые могут быть использованы в классах тестов. Вот сводная таблица этих хуков:
#таблица 

| Хук                     | Описание                                                                                                           | Когда вызывается                                   |
|-------------------------|--------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| `setup_class`           | Используется для установки состояния, которое будет доступно всем тестам в классе.                                  | Один раз перед выполнением первого теста в классе. |
| `teardown_class`        | Используется для очистки состояния после выполнения всех тестов в классе.                                          | Один раз после выполнения последнего теста в классе.|
| `setup_method`          | Используется для установки состояния перед каждым методом.                                                         | Перед каждым тестовым методом в классе.            |
| `teardown_method`       | Используется для очистки состояния после каждого метода.                                                           | После каждого тестового метода в классе.           |
| `setup` / `teardown`    | Устаревшие методы, аналогичные `setup_method` и `teardown_method`.                                                 | Так же, как `setup_method` и `teardown_method`.    |

Эти хуки используются внутри классов тестов и позволяют управлять подготовкой и очисткой состояния для тестов. Все они должны быть определены как `@classmethod`, кроме `setup_method` и `teardown_method`, которые являются обычными методами. 

Пример использования:

```python
import pytest

class TestSample:
    @classmethod
    def setup_class(cls):
        # Код для инициализации, который выполнится один раз перед началом тестов в классе
        pass

    @classmethod
    def teardown_class(cls):
        # Код для очистки, который выполнится один раз после завершения всех тестов в классе
        pass

    def setup_method(self, method):
        # Код для установки состояния перед каждым тестовым методом
        pass

    def teardown_method(self, method):
        # Код для очистки состояния после каждого тестового метода
        pass

    def test_example(self):
        # Тестовый метод
        pass
```

Применение этих хуков позволяет гарантировать, что тесты в классе будут исполняться в контролируемом и предсказуемом окружении.


Да, можно использовать фикстуры с `yield` и параметризацию в классах тестов в PyTest. Это позволяет создавать мощные и гибкие тестовые сценарии. Давайте рассмотрим, как это можно сделать, на примерах.

### Использование Фикстур с `yield` в Классах Тестов

Фикстуры с `yield` позволяют выполнять код для подготовки перед тестом и для очистки после теста. Это особенно полезно для управления ресурсами.

#### Пример:

```python
import pytest

# Фикстура с yield
@pytest.fixture(scope="function")
def resource():
    print("Настройка ресурса")
    yield "Ресурс"
    print("Очистка ресурса")

class TestExample:
    # Использование фикстуры в классе тестов
    def test_one(self, resource):
        print("Тест 1 использует", resource)
        assert resource == "Ресурс"

    def test_two(self, resource):
        print("Тест 2 использует", resource)
        assert resource == "Ресурс"
```

В этом примере фикстура `resource` настраивает ресурс перед тестом и выполняет очистку после теста. Фикстура передает строку "Ресурс" в тестовые методы.

### Параметризация в Классах Тестов

Вы можете использовать параметризацию в классах тестов, но для этого нужно немного по-другому структурировать ваш класс, используя статический метод `pytest.mark.parametrize`.

#### Пример:

```python
import pytest

class TestParametrizedExample:
    # Параметризация на уровне класса
    @pytest.mark.parametrize("number", [1, 2, 3])
    def test_numbers(self, number):
        assert number > 0
```

В этом примере каждый тест в классе `TestParametrizedExample` будет выполнен три раза, с `number` равным 1, 2 и 3.

### Комбинирование Параметризации и Фикстур с `yield` в ООП тестах

Вы можете комбинировать и параметризацию, и фикстуры с `yield` в классах тестов.

#### Пример:

```python
import pytest

# Параметризованная фикстура
@pytest.fixture(scope="function", params=[1, 2, 3])
def number(request):
    return request.param

class TestCombination:
    def test_number(self, number):
        assert number > 0
```

Здесь фикстура `number` параметризована: каждый тест в классе `TestCombination` будет выполнен три раза с разными значениями `number` (1, 2 и 3).

Фикстура в PyTest не может быть определена как обычный метод класса. Фикстуры в PyTest создаются как функции на уровне модуля, используя декоратор `@pytest.fixture`. Они предназначены для предоставления данных, состояния или ресурсов для тестов и отделены от логики тестовых классов.

Фикстуры предоставляют ряд преимуществ перед использованием методов класса для настройки и очистки тестов:

1. **Повторное Использование**: Фикстуры могут быть легко переиспользованы в различных тестах и тестовых классах в пределах одного тестового модуля или даже между модулями.
    
2. **Гибкость**: Фикстуры могут быть параметризованы, могут использовать другие фикстуры и могут быть настроены с разными областями действия (scope), такими как `'function'`, `'class'`, `'module'` или `'session'`.
    
3. **Ясное Разделение Ответственности**: Фикстуры обычно используются для настройки и предоставления определенных ресурсов или состояний, тогда как тестовые классы и методы сосредоточены на самом тестировании логики.
    

Тем не менее, если вам нужно выполнить настройку или очистку специфичную для класса, вы можете использовать методы класса, такие как `setup_class`/`teardown_class` и `setup_method`/`teardown_method`, которые предоставляет PyTest.
### Заключение

Использование фикстур с `yield` и параметризации в классах тестов позволяет создавать высокоуровневые, гибкие тестовые сценарии в PyTest. Эти механизмы помогают управлять ресурсами и обеспечивать различные условия тестирования для более полного покрытия тестами.
## Тестирование БД

```python
"""  
Поместите это к себе в папку с проектом и запустите тесты.  
Файл с запросами должен называться hw_32.sql  
Не нормализованная БД marvel_not_normal.db должна находиться в той же папке, что и файл с тестами.  
"""  
  
import os  
import sqlite3  
import pytest  
  
DB_PATH = "marvel_not_normal.db"  
SQL_FILE = "hw_32.sql"  
  
TABLES = [  
    'Sex',  
    'EyeColor',  
    'HairColor',  
    'Alignment',  
    'LivingStatus',  
    'Identity',  
    'MarvelCharacters'  
]  
COLUMNS_MARVEL_CHARACTERS = [  
    'id',  
    'page_id',  
    'name',  
    'urlslug',  
    'identity_id',  
    'align_id',  
    'eye_id',  
    'hair_id',  
    'sex_id',  
    'status_id',  
    'APPEARANCES',  
    'FIRST_APPEARANCE',  
    'Year'  
]  
  
  
def test_db_exists():  
    assert os.path.exists(DB_PATH), f"Файл БД {DB_PATH} не найден"  
  
  
# Измененная фикстура для управления транзакциями  
@pytest.fixture(scope="module")  
def conn():  
    connection = sqlite3.connect(DB_PATH)  
    cursor = connection.cursor()  
    cursor.execute("BEGIN")  
    yield connection  
    connection.rollback()  
    connection.close()  
  
  
def test_sql_queries(conn):  
    with open(SQL_FILE, 'r', encoding='utf-8') as f:  
        sql_queries = f.read()  
    conn.executescript(sql_queries)  
  
  
@pytest.mark.parametrize("table_name", TABLES)  
def test_table_exists(conn, table_name):  
    cursor = conn.cursor()  
    cursor.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name='{table_name}';")  
    assert cursor.fetchone() is not None, f"Таблица {table_name} не найдена"  
  
  
@pytest.mark.parametrize("column", COLUMNS_MARVEL_CHARACTERS)  
def test_marvel_characters_table_columns(conn, column):  
    cursor = conn.cursor()  
    cursor.execute(f"PRAGMA table_info(MarvelCharacters);")  
    columns = [info[1] for info in cursor.fetchall()]  
    assert column in columns, f"Поле {column} не найдено в таблице MarvelCharacters"
```

Давайте подробно разберем структуру этих тестов и объясним использование `yield` в фикстуре PyTest.

### Общая Структура Тестов

1. **Импорты и Константы**: В начале файла импортируются необходимые модули (`os`, `sqlite3`, `pytest`) и определяются константы (`DB_PATH`, `SQL_FILE`, `TABLES`, `COLUMNS_MARVEL_CHARACTERS`), представляющие путь к базе данных, путь к SQL файлу и список таблиц и колонок для тестирования.

2. **Функция `test_db_exists`**:
   - Это тест, который проверяет, существует ли файл базы данных (`DB_PATH`). Если файл не найден, тест провалится с соответствующим сообщением.

3. **Фикстура `conn`**:
   - Это фикстура PyTest, которая устанавливает соединение с базой данных. Фикстура использует `scope="module"`, что означает, что она будет вызвана один раз для каждого тестового модуля.
   - Внутри фикстуры используется `yield`, который возвращается в тесты соединение с базой данных. После выполнения тестов выполняется код после `yield`, который в данном случае закрывает соединение и откатывает транзакцию (`rollback`).

4. **Тест `test_sql_queries`**:
   - Этот тест читает SQL запросы из файла и выполняет их в базе данных. Это может быть использовано для инициализации тестовых данных.

5. **Параметризированные Тесты**:
   - `test_table_exists` и `test_marvel_characters_table_columns` являются параметризированными тестами. Они используют `@pytest.mark.parametrize` для запуска теста несколько раз с разными параметрами (имена таблиц и колонок).

### Использование `yield` в Фикстуре `conn`

- **Начало Транзакции**: Перед `yield`, фикстура устанавливает соединение с базой данных и начинает транзакцию. Это означает, что все изменения, сделанные в базе данных во время тестов, будут частью этой транзакции.

- **`yield`**: Ключевое слово `yield` используется для передачи контроля тестам. После этого PyTest продолжит выполнение тестов, которые используют фикстуру `conn`.

- **Откат Транзакции**: После выполнения всех тестов, которые используют эту фикстуру, контроль возвращается обратно в фикстуру, и код после `yield` выполняется. Здесь происходит откат транзакции (`rollback`), который отменяет все изменения, сделанные в базе данных во время тестов. Это возвращает базу данных в состояние, в котором она была до начала тестирования.

- **Закрытие Соединения**: После отката транзакции соединение с базой данных закрывается.

Выбор между `return` и `yield` в фикстуре PyTest зависит от того, нужно ли выполнять какие-либо действия после завершения тестов, использующих эту фикстуру.

### Использование `return` в Фикстуре

`return` используется, когда вам нужно просто предоставить данные или объект для тестов, и нет необходимости в дополнительных действиях по очистке или восстановлению после выполнения теста. 

Пример фикстуры с `return`:

```python
@pytest.fixture
def simple_data():
    data = [1, 2, 3]
    return data
```

В этом случае, фикстура `simple_data` просто возвращает список `[1, 2, 3]`, и после завершения теста, использующего эту фикстуру, нет необходимости в дополнительных действиях.

### Использование `yield` в Фикстуре

`yield` используется, когда вам нужно выполнять некоторые действия по очистке или восстановлению после того, как тесты, использующие фикстуру, завершены. Это особенно полезно для ресурсов, которые требуют закрытия или освобождения, например, соединения с базой данных, открытые файлы, сетевые соединения и т.д.

Пример фикстуры с `yield`:

```python
@pytest.fixture
def db_connection():
    conn = create_database_connection()  # Предположим, это функция создания соединения с БД
    yield conn
    conn.close()  # Закрытие соединения после завершения теста
```

Здесь фикстура `db_connection` сначала устанавливает соединение с базой данных, затем передает управление тесту (после ключевого слова `yield`). Как только тест завершается, выполнение возвращается обратно в фикстуру, и выполняется код после `yield`, в данном случае — закрытие соединения с базой данных.

### Как `yield` Работает в Фикстурах

1. **Инициализация**: Когда тест, который использует фикстуру, начинает выполняться, PyTest сначала исполняет код фикстуры до точки, где встречает `yield`.
    
2. **Передача Управления Тесту**: При достижении `yield`, фикстура "приостанавливается", и значение, следующее за `yield`, передается в тест в качестве результата фикстуры. Тест затем выполняется как обычно.
    
3. **Возобновление и Очистка**: После того как тест завершен, управление возвращается обратно к фикстуре, и исполняется код после `yield`. Этот код обычно содержит действия по очистке или закрытию ресурсов.
    
4. **Множественное Использование**: Если фикстура используется несколькими тестами, то процесс инициализации и очистки выполняется для каждого теста, если скоуп фикстуры - `function`. Если скоуп - `module` или `session`, то инициализация и очистка выполняется один раз на весь модуль или сессию соответственно.
    
### Пример с `yield` в Фикстуре

python

`@pytest.fixture def resource():     res = setup_resource()     yield res     teardown_resource(res)`

В этом примере:

- `setup_resource()` вызывается для инициализации ресурса перед тестом.
- `res` передается тесту.
- После завершения теста (или тестов, если фикстура используется несколькими тестами) выполняется `teardown_resource(res)`, чтобы освободить ресурсы.

### Важное Отличие от Генераторов

Хотя механизм `yield` в фикстурах напоминает работу генераторов, важно понимать, что в контексте PyTest он используется для других целей. В генераторах `yield` применяется для последовательного возвращения значений при каждом вызове, в фикстурах PyTest `yield` используется для разделения кода фикстуры на часть до теста и часть после теста, что особенно полезно для управления ресурсами и выполнения очистки.
## 3. Тестирование веб-приложений 🌐

Для тестирования веб-приложений с использованием Pytest удобно применять плагин `pytest-django`. Он предоставляет интеграцию Pytest с Django и включает набор полезных функций, таких как фикстуры для работы с базами данных и клиентами для тестирования представлений.

### 3.1. Установка плагина

```bash
pip install pytest-django
```

### 3.2. Настройка проекта

В файле `pytest.ini` укажите следующие параметры:

```ini
[pytest]
DJANGO_SETTINGS_MODULE = myproject.settings
```

и замените `myproject.settings` на определенный модуль настроек Django.

### 3.3. Пример теста

```python
from django.urls import reverse
from pytest_django.asserts import assertTemplateUsed

def test_view(client):
    response = client.get(reverse('my_view'))
    assert response.status_code == 200
    assertTemplateUsed(response, 'my_view.html')
```

## 4. Работа с базами данных 📊

Тестирование кода, взаимодействующего с базой данных, требует одновременной изоляции и быстроты. 

### 4.1. Использование транзакций и фикстур для тестов

Pytest с плагином `pytest-django` предоставляет фикстуру `transactional_db`, которая обеспечивает доступ к базе данных для каждого теста и обеспечивает корректный rollback данных после их выполнения.

```python
def test_database_access(transactional_db):
    # выполнение тестового запроса к базе данных
    assert # условие для проверки результата
```
Да, для Flask существуют инструменты и расширения, аналогичные `pytest-django` для Django, предназначенные для облегчения тестирования приложений на Flask. Одним из таких инструментов является `pytest-flask`.

### pytest-flask:
`pytest-flask` — это плагин для Pytest, который предоставляет набор фикстур и утилит для тестирования Flask-приложений. Он упрощает процесс тестирования, предоставляя инструменты для работы с контекстом приложения, клиентом для тестирования запросов и другими полезными функциями.

#### Функции pytest-flask:
- **Фикстуры для клиента тестирования**: Позволяет отправлять тестовые запросы к приложению.
- **Контекст приложения и запросов**: Автоматически управляет контекстом приложения и запросов для каждого теста.
- **URL-для тестов**: Упрощает тестирование маршрутов и представлений.

### Аналог `transactional_db` для Flask:
В Django `transactional_db` используется для обеспечения каждого теста свежей транзакцией базы данных. В Flask нет встроенного аналога `transactional_db`, но вы можете достичь подобного поведения, используя фикстуры Pytest и расширения для работы с базой данных.

#### Создание фикстуры для транзакций:
1. **Использование SQLAlchemy с Flask**: Если вы используете SQLAlchemy в своем Flask-приложении, вы можете использовать его возможности управления транзакциями для создания и отката транзакций перед и после каждого теста.

2. **Использование Flask-SQLAlchemy**: Если вы используете расширение Flask-SQLAlchemy, вы можете создать фикстуру, которая инициализирует базу данных перед каждым тестом и уничтожает её после теста, используя механизмы создания и удаления таблиц.

3. **Откат транзакций**: Вы можете начать транзакцию в начале каждого теста и откатывать её после выполнения теста, чтобы каждый тест работал с "чистым" состоянием базы данных.

### Заключение:
Хотя `pytest-flask` не предоставляет прямой аналог `transactional_db`, вы можете использовать его возможности вместе с инструментами управления базами данных, чтобы создать эффективную и изолированную среду тестирования для Flask-приложений. Это позволит вам тестировать ваше приложение в условиях, близких к реальным, и обеспечить его надежность и стабильность.
## 5. CI/CD интеграция 🔄

Интеграция Pytest в процесс непрерывной интеграции (CI) и непрерывной доставки (CD) зависит от используемого инструмента, но задача заключается в настройке выполнения тестов при каждом изменении кода.

### 5.1. Настройка Pytest в CI/CD

Пример настройки Pytest для GitHub Actions:

```yaml
name: Run tests
on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
    - name: Run tests
      run: pytest
```

## 6. Лучшие практики написания тестов ✍️

- **Именование тестов**: Используйте префикс `test_` для именования функций тестов и четкое описание для названия теста.
- **Изолированность тестов**: Отказ от зависимостей между тестами и использование фикстур позволяет избежать сайд-эффектов и вызывать тесты независимо.
- **Подробные сообщения об ошибках**: Используйте `assert` с явным описанием ошибки в случае ошибки теста.
- **Компактность**: Тестировать отдельные юниты, а не сценарии в целом, предотвращая слишком большие и медленные тесты.
- **Не использовать print**: Вывод ошибок через print снижает преимущества использования тестирования Pytestución.
```
