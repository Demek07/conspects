
## SQLite3 - Библиотека Python

Библиотека `sqlite3` в Python — это встроенный модуль, предоставляющий интерфейс для работы с базами данных SQLite. SQLite — это легковесная дисковая база данных, не требующая отдельного серверного процесса для работы. Это делает ее идеальной для приложений, требующих встроенной базы данных с минимальными требованиями к системным ресурсам, таких как мобильные приложения, небольшие веб-проекты и настольные приложения.

### Основные концепции

- **Встроенность:** SQLite является встроенной СУБД, что означает, что она полностью содержится в одном исполняемом файле без необходимости во внешних серверах или процессах.
- **База данных как файл:** Вся база данных SQLite, включая таблицы, индексы, триггеры и т. д., хранится в одном файле на диске. Это упрощает управление базой данных, так как для создания резервной копии, переноса или восстановления базы данных достаточно скопировать или переместить файл.
- **Транзакции:** SQLite поддерживает транзакции, что обеспечивает согласованность данных даже в случае сбоев системы или отключения питания. Транзакции в SQLite соответствуют стандарту ACID (атомарность, согласованность, изоляция, долговечность).
- **Мультиязычность:** SQLite поддерживает множество типов данных SQL, включая текст, числа, даты и булевы значения.

### Как работает

- **Подключение к базе данных:** Чтобы начать работу с базой данных SQLite в Python, необходимо сначала создать соединение с файлом базы данных. Если файл не существует, SQLite автоматически создаст его.
- **Создание объекта курсора:** После установления соединения вы создаете объект курсора, который позволяет выполнять SQL-запросы к базе данных.
- **Выполнение SQL-запросов:** С помощью методов курсора можно выполнять различные SQL-запросы для управления данными и структурой базы данных, включая запросы на выборку (SELECT), вставку (INSERT), обновление (UPDATE) и удаление (DELETE), а также для управления схемой базы данных, например, создание или удаление таблиц.
- **Фиксация транзакций:** После выполнения изменяющих данные операций (например, INSERT, UPDATE, DELETE) необходимо зафиксировать транзакцию, чтобы изменения были сохранены в базе данных.
- **Закрытие соединения:** После завершения работы с базой данных соединение следует закрыть, чтобы освободить системные ресурсы.

### Типы запросов

Библиотека `sqlite3` поддерживает широкий спектр SQL-запросов, включая:
- **DDL (Data Definition Language):** Запросы для определения или изменения структуры базы данных, например, CREATE TABLE для создания таблиц, ALTER TABLE для изменения таблиц, DROP TABLE для удаления таблиц.
- **DML (Data Manipulation Language):** Запросы для управления данными, включая INSERT для добавления данных, UPDATE для изменения данных и DELETE для удаления данных.
- **DQL (Data Query Language):** Запросы SELECT для выборки данных из базы данных.
- **Транзакционные операции:** Включают BEGIN TRANSACTION для начала транзакции, COMMIT для ее завершения и сохранения изменений, а также ROLLBACK для отмены изменений в рамках текущей транзакции.

Библиотека `sqlite3` в Python предоставляет удобный и эффективный интерфейс для работы с базами данных SQLite, делая ее отличным выбором для множества приложений, требующих легковесных и надежных решений для хранения данных.

Библиотека `sqlite3` в Python предоставляет простые и мощные инструменты для работы с базами данных SQLite. Давайте разберемся с основами этой библиотеки, включая подключение к базе данных, основные объекты и методы, а также примеры использования.

### Основные инструменты и объекты

1. **Подключение к базе данных**: Для начала работы с базой данных SQLite необходимо установить соединение. Это делается с помощью функции `connect()`, которая принимает в качестве аргумента путь к файлу базы данных. Если файл не существует, SQLite создаст его.

   ```python
   import sqlite3
   conn = sqlite3.connect('example.db')
   ```
   Этот код создает (или открывает, если он уже существует) файл базы данных `example.db`.



2. **Объект курсора**: Для выполнения SQL-запросов используется объект курсора. Курсор создается вызовом метода `cursor()` объекта соединения.

   ```python
   cursor = conn.cursor()
   ```
   С помощью курсора можно выполнять запросы к базе данных.

3. **Выполнение SQL-запросов**: SQL-запросы выполняются с помощью метода `execute()` объекта курсора.

   - **Создание таблицы**:
     ```python
     cursor.execute('''CREATE TABLE if not exists inventory
                       (item_id INTEGER PRIMARY KEY, name TEXT, quantity INTEGER)''')
     ```
     Этот запрос создает таблицу `inventory` с тремя столбцами: `item_id`, `name` и `quantity`.

   - **Вставка данных**:
     ```python
     cursor.execute("INSERT INTO inventory (name, quantity) VALUES ('Apple', 3)")
     ```
     Добавляет в таблицу `inventory` запись с названием товара 'Apple' и количеством 3.

   - **Выборка данных**:
     ```python
     cursor.execute("SELECT * FROM inventory")
     print(cursor.fetchall())
     ```
     Выбирает все записи из таблицы `inventory` и выводит их на экран. Метод `fetchall()` возвращает все строки из последнего выполненного запроса.

4. **Фиксация транзакций**: После выполнения операций, изменяющих данные (например, INSERT, UPDATE, DELETE), необходимо вызвать метод `commit()` объекта соединения, чтобы изменения были сохранены в базе данных.

   ```python
   conn.commit()
   ```

5. **Закрытие соединения**: По завершении работы с базой данных следует закрыть соединение с помощью метода `close()`.

   ```python
   conn.close()
   ```

### Методы объекта курсора и соединения

- **`cursor.execute(sql, [parameters])`**: Выполняет один SQL-запрос. Параметры можно передать вторым аргументом для предотвращения SQL-инъекций.
- **`cursor.executemany(sql, seq_of_parameters)`**: Позволяет выполнить SQL-запрос многократно с разными значениями параметров.
- **`cursor.fetchall()`**: Возвращает все строки результата последнего запроса.
- **`cursor.fetchone()`**: Возвращает следующую строку результата запроса.
- **`conn.commit()`**: Сохраняет все изменения, сделанные в транзакции.
- **`conn.close()`**: Закрывает соединение с базой данных.

Эти основные инструменты и методы обеспечивают весь необходимый функционал для работы с базами данных SQLite в Python, позволяя легко выполнять операции создания, чтения, обновления и удаления данных (CRUD).


Методы объекта курсора в библиотеке `sqlite3` предоставляют различные способы взаимодействия с базой данных SQLite. Основные методы включают `execute()`, `executemany()`, и `executescript()`. Каждый из них имеет свои особенности и применяется в соответствующих сценариях.

### `execute()`

Метод `execute()` используется для выполнения одного SQL-запроса. Это может быть запрос на выборку данных, вставку, обновление, удаление или операции с структурой базы данных, такие как создание или удаление таблиц.

- **Особенности**:
  - Позволяет передавать параметры в запрос, что делает его удобным для предотвращения SQL-инъекций.
  - Параметры передаются в виде кортежа или словаря.
  - Возвращает сам объект курсора, что позволяет цепочечно вызывать другие методы, например, `fetchone()` или `fetchall()` для получения результатов запроса.

```python
conn.execute("PRAGMA foreign_keys = ON;")
```
Этот параметр **позволяет включить проверку ссылочной целостности в SQLite.** Когда он включен, SQLite будет проверять, что все внешние ключи имеют соответствующие родительские ключи при выполнении операций INSERT и UPDATE, и предотвращать действия, которые нарушают ссылочную целостность. Это полезно для обеспечения целостности данных в базе данных.

### `executemany()`

Метод `executemany()` принимает SQL-запрос и последовательность параметров и выполняет этот запрос многократно, подставляя каждый раз новый набор параметров. Это особенно полезно для вставки или обновления множества записей одним вызовом.

- **Особенности**:
  - Повышает эффективность операций пакетной обработки данных по сравнению с многократным вызовом `execute()`.
  - Не делает автокоммиты. В SQLite транзакция начинается автоматически перед серией операций вставки/обновления/удаления и должна быть явно завершена вызовом `commit()` на объекте соединения для фиксации изменений.
  - Возвращает объект курсора.

### `executescript()`

Метод `executescript()` предназначен для выполнения множества SQL-запросов за один вызов. В отличие от `execute()` и `executemany()`, этот метод может выполнять несколько SQL-запросов, разделенных точкой с запятой, что делает его идеальным для выполнения SQL-скриптов.

Пример кода 

для использования метода `executescript()`:

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# SQL-скрипт, содержащий несколько запросов
script = '''
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER
);

INSERT INTO users (name, age) VALUES ('Alice', 30);
INSERT INTO users (name, age) VALUES ('Bob', 25);
'''

# Выполнение SQL-скрипта с помощью executescript()
cursor.executescript(script)

# Сохранение изменений и закрытие соединения
conn.commit()
conn.close()
```

В этом примере мы создаем базу данных SQLite и выполняем SQL-скрипт, который создает таблицу `users` и добавляет две записи в эту таблицу. Метод `executescript()` позволяет выполнить оба SQL-запроса за один вызов.

- **Особенности**:
  - Автоматически выполняет коммит перед началом выполнения и после завершения всех запросов в скрипте. Это означает, что если в скрипте содержится несколько операций, изменяющих данные, изменения будут автоматически сохранены после выполнения скрипта.
  - Подходит для выполнения сложных скриптов с множеством последовательных операций, включая создание или модификацию структуры базы данных и манипуляции с данными.
  - Возвращает объект курсора.

### Дополнительная важная информация

- **Параметризация запросов**: Все три метода поддерживают параметризованные запросы, что помогает защитить от SQL-инъекций. Параметры в `execute()` и `executemany()` можно передавать как позиционные, так и именованные.
- **Управление транзакциями**: SQLite использует механизм логических блокировок для управления транзакциями. По умолчанию, каждый отдельный SQL-запрос выполняется в рамках своей транзакции, если только не было явно начато выполнение транзакции. Понимание этого механизма важно для эффективного управления транзакциями и

 избежания потери данных.
- **Производительность**: Использование `executemany()` для пакетной вставки или обновления данных может значительно повысить производительность по сравнению с многократным вызовом `execute()` для каждой записи. Однако стоит помнить, что открытая транзакция может блокировать таблицу для других операций, поэтому важно своевременно выполнять `commit()`.

Понимание этих методов и их особенностей поможет эффективно работать с базами данных SQLite в Python, обеспечивая высокую производительность и безопасность ваших приложений.


### Автокоммит в `executemany` и SQLite

В контексте SQLite и библиотеки `sqlite3` в Python, автокоммит является частью управления транзакциями. По умолчанию, SQLite работает в режиме автокоммита, когда каждая операция SQL запускается в своей транзакции и автоматически фиксируется. Однако, использование `executemany` само по себе не вызывает автокоммит после каждой вставки. Автокоммит происходит, если не была явно начата транзакция. Если нужно отключить автокоммит во время использования `executemany`, можно явно начать транзакцию с помощью `BEGIN TRANSACTION` и завершить её вызовом `commit()` после выполнения `executemany`.

### SQL инъекция

SQL инъекция — это вид атаки на приложение, при которой злоумышленник может внедрить или "инъецировать" произвольный SQL код в запрос, изменяя его оригинальное назначение. Это может привести к несанкционированному доступу к данным, их изменению или удалению. В контексте Python и SQLite, защита от SQL инъекций обеспечивается использованием параметризованных запросов, где данные передаются отдельно от команды SQL и корректно экранируются.

### Тестирование запросов в pytest

Для тестирования запросов к базе данных в pytest можно использовать виртуальные таблицы и фикстуры. Фикстуры с `yield` позволяют настроить тестовую среду перед выполнением теста и очистить её после, что идеально подходит для тестирования взаимодействия с базой данных.

Пример фикстуры для создания и удаления тестовой базы данных:

```python
import pytest
import sqlite3

@pytest.fixture
def db():
    conn = sqlite3.connect(":memory:")  # Создание базы данных в памяти
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE test_table (id INTEGER PRIMARY KEY, value TEXT)''')
    yield conn  # Возвращает объект соединения для использования в тесте
    conn.close()  # Закрытие соединения после завершения теста
```

Такая фикстура позволяет каждому тесту работать с собственной чистой копией базы данных, что обеспечивает изоляцию и повторяемость тестов.

### Параллельное чтение/запись в SQLite

SQLite поддерживает параллельное чтение, но запись в базу данных может производиться только одним процессом или потоком одновременно из-за механизма блокировок. Для управления конкурентным доступом SQLite использует несколько режимов изоляции транзакций, включая режим WAL (Write-Ahead Logging), который позволяет читателям продолжать чтение из базы данных в то время, как другая транзакция записывает данные.

Пример использования SQLite в Python для обеспечения конкурентного доступа в режиме WAL:

```python
import sqlite3

conn = sqlite3.connect('example.db')
conn.execute('PRAGMA journal_mode=WAL;')  # Включение режима WAL

# Теперь можно безопасно читать данные в одном потоке, в то время как другой поток выполняет запись
```

Использование режима WAL облегчает разработку приложений, где требуется высокая доступность и конкурентный доступ к базе данных

 для чтения, но всё же требует внимательного управления транзакциями для избежания конфликтов и "голодания" записывающих процессов.

Для тестирования и проверки структуры базы данных SQLite, а также для подготовки параметризированных тестов в контексте домашних заданий студентов, можно использовать ряд служебных запросов. Эти запросы позволяют извлекать информацию о таблицах, столбцах, типах данных и ключах. Давайте рассмотрим основные из них.

### Получение информации о таблицах

Чтобы получить список всех таблиц в базе данных SQLite, можно использовать следующий запрос к служебной таблице `sqlite_master`:

```sql
SELECT name FROM sqlite_master WHERE type='table';
```

Этот запрос возвращает имена всех таблиц в базе данных.

### Получение информации о столбцах таблицы

Для получения списка столбцов определенной таблицы и информации о них можно использовать запрос `PRAGMA table_info()`:

```sql
PRAGMA table_info('имя_таблицы');
```

Этот запрос вернет информацию о каждом столбце в таблице, включая идентификатор столбца, имя, тип данных, признак необходимости значения (not null) и значение по умолчанию.

### Получение информации о первичных и внешних ключах

- **Первичные ключи**: Информация о первичных ключах также возвращается запросом `PRAGMA table_info()`, где для столбцов, являющихся частью первичного ключа, будет установлено специальное значение.

- **Внешние ключи**: Для получения информации о внешних ключах таблицы можно использовать запрос `PRAGMA foreign_key_list()`:

  ```sql
  PRAGMA foreign_key_list('имя_таблицы');
  ```

  Этот запрос вернет список внешних ключей для указанной таблицы, включая имя столбца в текущей таблице, имя связанной таблицы и имя столбца в связанной таблице.

### Параметризированные тесты в pytest

Для тестирования наличия таблиц, столбцов и ключей можно использовать параметризированные тесты в `pytest`. Пример параметризации для проверки наличия таблиц:

```python
import pytest
import sqlite3

# Предположим, у нас есть функция для получения списка таблиц
def get_tables(db_path):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = cursor.fetchall()
    conn.close()
    return [t[0] for t in tables]

# Параметризированный тест для проверки наличия определенных таблиц
@pytest.mark.parametrize('table_name', ['students', 'courses'])
def test_table_exists(db_path, table_name):
    assert table_name in get_tables(db_path)
```

Аналогичный подход можно использовать для тестирования наличия столбцов и проверки свойств ключей, используя служебные запросы `PRAGMA table_info()` и `PRAGMA foreign_key_list()` для получения необходимой информации и параметризацию в `pytest` для определения тестовых случаев.

Такие служебные запросы и подходы к тестированию могут быть очень полезны при автоматизации проверки структуры баз данных в домашних заданиях студентов, обеспечивая эффективную и точную проверку соответствия заданным требованиям.


Давайте разберем примеры использования методов `execute`, `executemany`, и `executescript` из библиотеки `sqlite3` в Python, объясняя каждый шаг для лучшего понимания.

### `execute` с подстановкой данных

Метод `execute` используется для выполнения одного SQL-запроса. Особенно полезен для вставки, обновления, удаления данных или выполнения запросов на выборку.

**Пример**:
```python
import sqlite3

conn = sqlite3.connect('example.db')  # Подключаемся к базе данных
cursor = conn.cursor()  # Создаем курсор

# Вставка данных с подстановкой переменных
name = 'Alice'
age = 30
cursor.execute("INSERT INTO People (name, age) VALUES (?, ?)", (name, age))

conn.commit()  # Сохраняем изменения
conn.close()  # Закрываем соединение
```
В этом примере `?` используется в качестве плейсхолдера для переменных `name` и `age`, которые подставляются в запрос. Это предотвращает SQL-инъекции и является рекомендуемым способом работы с динамическими данными.

### `executemany` для пакетной обработки

Метод `executemany` идеален для выполнения одного и того же SQL-запроса с разными значениями, например, при вставке нескольких строк данных одновременно.

**Пример**:
```python
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Пакетная вставка данных
people = [('Bob', 25), ('Cindy', 35), ('Dave', 20)]
cursor.executemany("INSERT INTO People (name, age) VALUES (?, ?)", people)

conn.commit()
conn.close()
```
Здесь `executemany` используется для вставки нескольких записей в таблицу `People`. Каждый элемент списка `people` представляет собой кортеж, который соответствует плейсхолдерам в SQL-запросе.

### `executescript` для выполнения нескольких SQL-запросов

Метод `executescript` позволяет выполнить несколько SQL-запросов за один вызов. Это полезно для выполнения скриптов SQL, содержащих несколько команд.

**Пример**:
```python
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполнение нескольких SQL-команд
script = """
CREATE TABLE IF NOT EXISTS Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);
INSERT INTO Products (name, price) VALUES ('Pen', 10);
INSERT INTO Products (name, price) VALUES ('Pencil', 5);
"""
cursor.executescript(script)

conn.commit()
conn.close()
```
В этом примере `executescript` используется для создания новой таблицы `Products` и вставки в нее двух строк. Метод идеально подходит для инициализации базы данных или выполнения миграций.

**Общие советы по использованию**:
- Всегда используйте подстановку переменных (`?`) в `execute` и `executemany` для предотвращения SQL-инъекций.
- После выполнения изменяющих данные операций не забудьте вызвать `commit()`, чтобы сохранить изменения.
- Закрывайте соединение с базой данных (`close()`) после выполнения всех необходимых операций для освобождения ресурсов.

Эти примеры должны дать студентам хорошее представление о том, как использовать основные методы `sqlite3` для работы с базами данных SQLite в Python.